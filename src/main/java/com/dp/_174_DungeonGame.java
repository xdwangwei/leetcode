package com.dp;

import java.util.Arrays;

/**
 * @author wangwei
 * 2021/12/12 10:52
 * <p>
 * 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
 * <p>
 * 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
 * <p>
 * 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
 * <p>
 * 为了尽快到达公主，骑士决定每次只向右或向下移动一步。
 * <p>
 * <p>
 * <p>
 * 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
 * <p>
 * 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
 * <p>
 * -2 (K)	-3	3
 * -5	-10	1
 * 10	30	-5 (P)
 * <p>
 * <p>
 * 说明:
 * <p>
 * 骑士的健康点数没有上限。
 * <p>
 * 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/dungeon-game
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class _174_DungeonGame {

    /**
     * 动态规划
     * <p>
     * 最值问题，二维数组，dp[i][j] 的定义往往有两种：从起点到当前位置的最小代价，从当前位置到终点的最小代价
     * <p>
     * 对于此题：
     * 如果 dp[i][j]表示从起点能够到达当前位置的最小体力值，那么对于dp[i][j]来说，它的可能来源是头顶dp[i-1][j]或左边dp[i][j-1]
     * 假设当前位置为 C， 头顶为 A, 左边 为 B
     * 你只知道 能够到达A和B所需的最小初始体力值，但不知道到达A和B时剩余的体力值，那么如何判断我选择从A还是从B到达C呢？
     * 实际上是不能的，除非我们同时保存到达每一个点时所需的最小初始体力值，到达当前位置的体力值，这样的话，至少需要两个二维数组
     * 第一是复杂度高，第二是 动态规划往往只需要一个 dp数组，这样解法效率也不高，dp的意义也不大。
     * <p>
     * 因此考虑第二种，dp[i][j]表示若能够从当前位置到达终点，那么到达当前位置时的体力值至少是多少
     * 这样的话，对于同样的问题，假如当前位置是C，它可能来自于脚下B或者右边A
     * 我知道从B到达终点所需的最小的体力值，也知道从A到达终点所需的最小体力值，那你说我选择A和B哪个呢？肯定是哪个小选择哪个啊！！！
     * 从A到终点只需要到达A时体力至少为2，从B到达终点需要到达B时体力至少是5，那么肯定选择从当前位置到A，再到达终点啊，
     * 这样的话我要保证 到达C时的体力值 + C位置能够获取(扣除)的体力值 >= 2，然后从右边A往终点走
     * <p>
     * 那么 dp[C] = min(dp[A], dp[B]) - nums[C], 另外我们需要保证到达每一个位置时体力始终是正的，所以 还要 满足，dp[C] = Math.max(dp[C], 1)
     * <p>
     * 状态转移方程：
     * dp[i][j] = max(min(dp[i + 1][j], dp[i][j+1]) - nums[i][j], 1)
     * <p>
     * 当 i,j 是终点时，如果这个点的num值本身为正，那么 dp[终点]=1，从此点到终点的初始体力值最少只需要1就可以。
     * 若为负数，那么 初始体力值 至少为 -nums[终点] + 1
     * <p>
     * <p>
     * 按照状态转移方程，双重 for 循环需要 均需要 倒序遍历。
     * 另外，对于 边界上的点，只存在 一种来源，比如 有边界的点 只能是它下面的点往上
     * 为了不单独区分这种情况，可以 给 dp 数组 扩大一个维度，初始值 填充 MAX，这样就不用单独考虑边界上的点。
     * <p>
     * 对于 base case i == m - 1 && j == n- 1 的初始化，
     * 可以直接单独给这个点的dp值初始化，然后在 for 循环中 跳过这个点，避免这个值被改。
     * dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
     * 或者不用单独初始化，因为 扩充了 dp 之后，按照状态转移方程
     * dp[m - 1][n - 1] = max(min(dp[m][n-1], dp[m-1][n]) - nums[m-1][n-1], 1)
     * 能够得到和上面一致的结果，并且这种情况下 for 循环中不用单独排除这个点，可以做到 全部统一。所以选择这种方式
     * 需要注意的是 因为给dp全部初始化为max了，所以 dp[m][n-1], dp[m-1][n] 这两个点需要单独赋值为1，它两本身不存在，无论从哪个到终点，都应该是1
     *
     * @param dungeon
     * @return
     */
    public int calculateMinimumHP(int[][] dungeon) {
        // if (dungeon == null || dungeon.length == 0 || dungeon[0] == null || dungeon[0].length == 0) {
        //     return ?????
        // }
        int m = dungeon.length, n = dungeon[0].length;
        // dp[i][j]表示若能够从当前位置到达终点，那么到达当前位置时的体力值至少是多少
        // 为了不单独考虑边界点，给dp扩充维度
        int[][] dp = new int[m + 1][n + 1];
        // 全部初始化为最大值
        for (int i = 0; i <= m; ++i) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        // dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
        // base case，保证 这两个点到终点都是1，保证终点能够从状态转移方程的得到正确的初始值
        dp[m][n - 1] = dp[m - 1][n] = 1;
        // 状态转移，只需要遍历 有效范围内的 i 和 j， 扩充出来的 维度 会被  dp[i + 1][j], dp[i][j+1] 用到。
        // 注意倒序遍历，并且终点dp[m - 1][n - 1]不用单独考虑。
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
                dp[i][j] = Math.max(1, dp[i][j]);
            }
        }
        // 返回从若要能够从起点到达终点，初始体力值至少是多少
        return dp[0][0];
    }

    /**
     * 状态压缩
     * dp[i][j] = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
     * 去掉 i 维度
     *
     * 需要注意的是，
     *      初始化 dp Arrays.fill(dp, Integer.MAX_VALUE);
     *      base case dp[n - 1] = 1;
     *      我们是把 dp[终点]的更新合并到状态转移方程了，不用单独考虑它了，
     *      但是当把dp压缩后，dp[n]就代表原来dp新增出的最后一列，这一列的值都是 MAX, 为了让原边界点不用被单独考虑，并且不能影响结果
     *      所以压缩dp后，dp[n]应该始终为MAX，因为这一列值不嫩改，
     *      在这种情况下，为了让 base case 终点能由状态转移方程正确的得到初始值
     *          dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];
     *      应该给 dp[n-1] 初始值赋值为1，因为按照递推式子 对于dp[n-1]的更新，必须保证dp[n-1], dp[n] 至少一个是1，才能得到正确的初始值
     *          // dp[终点] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
     *
     *      所以初始化是：
     *      Arrays.fill(dp, Integer.MAX_VALUE);
     *      dp[n - 1] = 1;
     *
     *  或者 把 对base case 的处理在 for循环中单独加个判断进行
     *          Arrays.fill(dp, Integer.MAX_VALUE);
     *         // 不需要单独给 dp[n-1]赋值
     *         // 注意倒序遍历，并且终点dp[m - 1][n - 1]不用单独考虑。
     *         for (int i = m - 1; i >= 0; --i) {
     *             for (int j = n - 1; j >= 0; --j) {
     *                   // 单独处理终点
     *                 if (i == m - 1 && j == n - 1) {
     *                     dp[j] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
     *                     continue;
     *                 }
     *                 dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];
     *                 dp[j] = Math.max(1, dp[j]);
     *             }
     *         }
     */
    public int calculateMinimumHP2(int[][] dungeon) {
        // if (dungeon == null || dungeon.length == 0 || dungeon[0] == null || dungeon[0].length == 0) {
        //     return ?????
        // }
        int m = dungeon.length, n = dungeon[0].length;
        // dp[i][j]表示若能够从当前位置到达终点，那么到达当前位置时的体力值至少是多少
        // 为了不单独考虑边界点，给dp扩充维度
        int[] dp = new int[n + 1];
        // 全部初始化为最大值
        Arrays.fill(dp, Integer.MAX_VALUE);
        // dp[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
        // base case，保证 这两个点到终点都是1，保证终点能够从状态转移方程的得到正确的初始值
        // dp[m][n - 1] = dp[m - 1][n] = 1;
        dp[n - 1] = 1;
        // 状态转移，只需要遍历 有效范围内的 i 和 j， 扩充出来的 维度 会被  dp[i + 1][j], dp[i][j+1] 用到。
        // 注意倒序遍历，并且终点dp[m - 1][n - 1]不用单独考虑。
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                if (i == m - 1 && j == n - 1) {
                    dp[j] = dungeon[m - 1][n - 1] > 0 ? 1 : -dungeon[m - 1][n - 1] + 1;
                    continue;
                }
                dp[j] = Math.min(dp[j], dp[j + 1]) - dungeon[i][j];
                dp[j] = Math.max(1, dp[j]);
            }
        }
        // 返回从若要能够从起点到达终点，初始体力值至少是多少
        return dp[0];
    }
}
