package com.daily;

import java.util.HashSet;
import java.util.Set;

/**
 * @author wangwei
 * @date 2023/1/11 19:42
 * @description: _753_CrackingTheSafe
 *
 * 753. 破解保险箱
 * 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。
 *
 * 保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。
 *
 * 例如，正确的密码是 "345" ，并且你输入的是 "012345" ：
 * 输入 0 之后，最后 3 位输入是 "0" ，不正确。
 * 输入 1 之后，最后 3 位输入是 "01" ，不正确。
 * 输入 2 之后，最后 3 位输入是 "012" ，不正确。
 * 输入 3 之后，最后 3 位输入是 "123" ，不正确。
 * 输入 4 之后，最后 3 位输入是 "234" ，不正确。
 * 输入 5 之后，最后 3 位输入是 "345" ，正确，打开保险箱。
 * 在只知道密码位数 n 和范围边界 k 的前提下，请你找出并返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 1, k = 2
 * 输出："10"
 * 解释：密码只有 1 位，所以输入每一位就可以。"01" 也能够确保打开保险箱。
 * 示例 2：
 *
 * 输入：n = 2, k = 2
 * 输出："01100"
 * 解释：对于每种可能的密码：
 * - "00" 从第 4 位开始输入。
 * - "01" 从第 1 位开始输入。
 * - "10" 从第 3 位开始输入。
 * - "11" 从第 2 位开始输入。
 * 因此 "01100" 可以确保打开保险箱。"01100"、"10011" 和 "11001" 也可以确保打开保险箱。
 *
 *
 * 提示：
 *
 * 1 <= n <= 4
 * 1 <= k <= 10
 * 1 <= kn <= 4096
 */
public class _753_CrackingTheSafe {

    /**
     * dfs / 回溯 / 欧拉回路
     *
     * 题目：密码有n位，每一位有 0，1，...，k-1 共 k 种选择，k <= 10，那么 密码共有 k ^ n 种选择
     * 要求输出字符串 s，s 包含了所有可能的密码情况，并且是所有可能结果中最短的
     *
     * 比如 n = 2, k = 2，密码可能是 00，01，10，11，
     * 最简单的答案是 将这四种密码组合拼在一起组成破解序列 seq = 00011011，这样得到的序列长度为 8，
     * 但是它不是包含所有密码组合的最短序列。最短序列应该是 00110，长度为 5
     *
     * 也就是说这种简单将所有组合拼接在一起的方法，得到的破解序列是有冗余的，会增加我们的破解时间。
     *
     * 最优方案是什么，根据题目中
     * “可以随意输入密码序列，保险箱会自动记住 最后 n 位输入”，
     * ”返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列“
     * 加入返回结果为 s，按照题目要求 在输入 s的过程中在任意位置停下，都应该能打开保险箱
     * 那么也就是说输入 s[i] 时，s[i]必然能够和前面n-1个字符组成答案，
     * 那么最短字符串 s 应该满足
     *      任意一个长度为 n 的子串 的 后 n-1 个字符 + 字符（0-k-1之间） 能够组成1个新的答案，并且不会在s中重复出现
     * 题目要求的 最短破解序列 就是不会产生冗余匹配的序列，长度正好是 k^n + (n - 1)，
     *
     * 转换为图的问题
     * 对于所有 m = k^n 个密码组合，我们把每个 n 位可能的密码看成是 图 中的一个 顶点，每个顶点有 k 条边，
     * 这个问题就是，对于这 m 个顶点构成的 完全图 中，让我们找到这样一个回路 v1 -> v2 -> v3-> ... -> vm ->v1，
     * 除起始顶点外，每个顶点访问且仅访问一次，
     * 其中 <u, v> 表示回路中一条由顶点 u 指向 v 的 边，且顶点 u 长度为 n-1 的后缀(或前缀)恰好是顶点 v 的前缀(或后缀)。
     * 最终我们要的 最短破解序列，其中一个就是 v1[0], v2[0], v3[0], ..., vm，长度为 k^n + (n - 1)，
     * 这个 最短破解序列 不止一个，因为 回路 中的任意一个顶点都可以做 起始顶点
     * （这里再回到上面 n = 3，k = 2 的例子会更好理解）
     *
     * 我们通过 dfs/回溯来解决这个问题，
     *      初始顶点设置为 start = "0".repeat(n)，
     *      一共需要访问 total = k^n 个顶点，且不能重复
     *      通过 set visited 来记录已访问到的节点，当 visited.size() == total 时，我们就完成了这次遍历
     *      当前顶点通过长度为n-1的后缀 + 从0到k-1任意选的一个字符组成下一个待访问节点【做选择】
     *      因为需要知道完整路径，所以要记录做的选择（每次选的是0到k-1哪个数字），
     *      整体上是回溯
     *      题目保证了一定有解，因此虽然回溯整体的复杂度很高，但是回溯的情况很少
     */

    // 记录访问过的节点
    private Set<String> visited = new HashSet<>();
    // 记录做的选择，最后答案
    private StringBuilder sb = new StringBuilder();
    int n;
    int k;
    // 总共节点数
    int total;

    public String crackSafe(int n, int k) {
        this.n = n;
        this.k = k;
        this.total = (int) Math.pow(k, n);
        // 初始节点
        String start = "0".repeat(n);
        // 标记访问
        visited.add(start);
        // 从start出发，记录节点，并记录回溯选择
        sb.append(start);
        // 一定有解
        dfs(start);
        // 返回 初始节点+路径
        return sb.toString();
    }

    // 回溯
    private boolean dfs(String node) {
        // 访问完了全部节点，结束
        if (visited.size() == total) {
            return true;
        }
        // 得到当前节点长度为n-1的后缀
        String suffix = node.substring(1);
        // 做选择
        for (int i = 0; i < k; ++i) {
            // 记录选择
            sb.append(i);
            // 得到新节点
            String nn = suffix + i;
            // 如果还未访问
            if (!visited.contains(nn)) {
                // 标记
                visited.add(nn);
                // 后续成功进行，返回
                if (dfs(nn)) {
                    return true;
                }
                // 撤销选择
                visited.remove(nn);
            }
            // 撤销当前记录
            sb.setLength(sb.length() - 1);
        }
        // 默认返回
        return false;
    }

    public static void main(String[] args) {
        _753_CrackingTheSafe obj = new _753_CrackingTheSafe();
        obj.crackSafe(1, 2);
    }
}
