package com.daily;

import java.util.Arrays;

/**
 * @author wangwei
 * @date 2023/4/7 22:58
 * @description: _1044_MovingStonesUntilConsecutive2
 *
 * 1040. 移动石子直到连续 II
 * 在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。
 *
 * 每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。
 *
 * 值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。
 *
 * 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。
 *
 * 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：[7,4,9]
 * 输出：[1,2]
 * 解释：
 * 我们可以移动一次，4 -> 8，游戏结束。
 * 或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
 * 示例 2：
 *
 * 输入：[6,5,4,3,10]
 * 输出：[2,3]
 * 解释：
 * 我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
 * 或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
 * 注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
 * 示例 3：
 *
 * 输入：[100,101,104,102,103]
 * 输出：[0,0]
 *
 *
 * 提示：
 *
 * 3 <= stones.length <= 10^4
 * 1 <= stones[i] <= 10^9
 * stones[i] 的值各不相同。
 *
 *
 * 通过次数10,567提交次数16,498
 */
public class _1044_MovingStonesUntilConsecutive2 {

    /**
     * 方法：分类讨论 + 滑动窗口
     *
     * 题目限制可以概括为：
     *      只能移动左右端点
     *      端点移动后不能还是端点
     *      游戏停止的条件是，石子连续递增（无空位）
     *
     * 最终目的是 n 个石子放在 i...i+n-1 这 n 个连续位置， i 是 原来石子位置 stones[i] 的某个位置
     *
     * 【一句话概括求解】：最多的情况就是将空位都踩一遍，有多少空位就需要多少步；最少情况就是找窗口大小为n最少空位，一步到位；
     *
     * 最大值求解方法：
     *
     * 石子可以放置的空间，等于左右两端石子之间的未占用位置。
     *
     * stones 简写为 s
     *
     * 先对 s 排序
     *
     * 开始时可以移动s[0] 或 s[n-1]，
     *
     * 那么 最大移动次数为：
     *      s[1] 到 s[n-1] 之间的空位个数  s[n-1] - s[1] - 1 - (n - 3) = s[n-1] - s[1] - n + 2
     *           s[1] 到 s[n-1] 之间 共 s[n-1] - s[1] - 1 个 空位
     *           需要安置的石子还有 n - (s[0], s[1], s[n-1] 这三个石子) = n - 3 个
     *           那么最后可用的空位有 s[n-1] - s[1] - 1 - (n - 3) = s[n-1] - s[1] - n + 2
     *           最大移动次数就是把这些空位全踩一次
     *      s[0] 到 s[n-2] 之间的空位个数  s[n-2] - s[0] - 1 - (n - 3) = s[n-2] - s[0] - n + 2
     *           与上同理
     *
     *      所以 maxMoves = max(s[n-1] - s[1] - n + 2, s[n-2] - s[0] - n + 2)
     *
     * 最小值求解方法：
     *
     * 既然端点可以移动到中间的任意空位上，那所有石子都「一步到位」肯定是移动次数最少的。
     * 所以问题变成：
     * 长为 n 的窗口内，最少有多少个空位？
     * 这等价于 n 减去窗口内的最多石子个数。
     *
     * 寻找窗口内最多的石子个数可以采用 滑动窗口
     * 石子索引 0，1，...，left，...，right，...
     * 窗口大小 s[right] - s[left] + 1，窗口内 石子个数 right - left + 1
     * 枚举窗口右端点所在石子位置 s[right]，计算窗口内的最大石子个数，
     * 最后用减去窗口内的最大石子个数即为最小移动次数。
     * 寻找的是长度为 n 的窗口内最多的石子个数
     * 所以窗口大小 s[right] - s[left] + 1 > n 时 缩小左窗口 left++
     *
     *
     * 特殊情况：
     *
     * 但是有一种特例：1，2，3，4，7，这种 1-4 是最好的序列，但是 7 不能移动到端点，只能 1 先移动到 6，然后 7 移动到 5 解决，
     * 这种情况要用 2 步。
     * 也就是最大移动次数的两种情况 s[n-1] - s[1] - n + 2 == 0  或  s[n-2] - s[0] - n + 2 == 0
     * 就是从s0]到s[n-2]之间或者从s[1]到s[n-1]之间没有空位，只在边上有空，要用 2 次
     * 那么答案为2，但这不应当比最大移动次数maxMove还大，所以这种情况的最小移动次数应为min(2,maxMove)。
     *
     * 如果不是特殊情况，窗口内至少有2个空位，所以在窗口滑动时，是无论如何都不会出现特殊情况的，不用特殊考虑。
     *
     * 作者：owenzzz
     * 链接：https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solution/jie-ti-si-lu-by-owenzzz/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param s
     * @return
     */
    public int[] numMovesStonesII(int[] s) {
        int n = s.length;
        // 排序
        Arrays.sort(s);
        // 最大移动一次，左右端点石子，所有空位全部踩一次
        int maxMoves = Math.max(s[n - 1] - s[1] - n + 2, s[n - 2] - s[0] - n + 2);
        // 特殊情况 从s0]到s[n-2]之间或者从s[1]到s[n-1]之间没有空位
        // 此时需要先将另一侧的端点移到自己这边来，自己才能往后移动，需要 2 次
        // 但这不应当比最大移动次数maxMove还大，所以这种情况的最小移动次数应为min(2,maxMove)。
        if (s[n-1] - s[1] - n + 2 == 0 || s[n-2] - s[0] - n + 2 == 0) {
            return new int[]{Math.min(2, maxMoves), maxMoves};
        }
        // 最小移动次数，排除了特殊情况后，窗口内至少有2个空位，所以在窗口滑动时，是无论如何都不会出现特殊情况的，不用特殊考虑。
        int left = 0, maxCnt = 0;
        // 石子索引 0，1，...，left，...，right，...
        // 窗口大小 s[right] - s[left] + 1，窗口内 石子个数 right - left + 1
        // 枚举右端点石子位置 s[right]
        for (int right = 0; right < n; ++right) {
            // 窗口大小 超过 n，寻找的是长度为 n 的窗口内最多的石子个数
            if (s[right] - s[left] + 1 > n) {
                // 缩小窗口
                left++;
            }
            // 用当前窗口内石子个数 更新 maxCnt
            maxCnt = Math.max(maxCnt, right - left + 1);
        }
        // 最小移动次数 n - maxCnt
        return new int[]{n - maxCnt, maxMoves};
    }
}
