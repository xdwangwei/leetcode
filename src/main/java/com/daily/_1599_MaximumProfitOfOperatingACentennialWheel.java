package com.daily;

/**
 * @author wangwei
 * @date 2023/3/5 12:20
 * @description: _1599_MaximumProfitOfOperatingACentennialWheel
 *
 * 1599. 经营摩天轮的最大利润
 * 你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。
 *
 * 给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。
 *
 * 你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。
 *
 * 返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：customers = [8,3], boardingCost = 5, runningCost = 6
 * 输出：3
 * 解释：座舱上标注的数字是该座舱的当前游客数。
 * 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。
 * 2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。
 * 3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。
 * 轮转 3 次得到最大利润，最大利润为 $37 。
 * 示例 2：
 *
 * 输入：customers = [10,9,6], boardingCost = 6, runningCost = 4
 * 输出：7
 * 解释：
 * 1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。
 * 2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。
 * 3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。
 * 4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。
 * 5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。
 * 6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。
 * 7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。
 * 轮转 7 次得到最大利润，最大利润为$122 。
 * 示例 3：
 *
 * 输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
 * 输出：-1
 * 解释：
 * 1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。
 * 2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。
 * 3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。
 * 4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。
 * 5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。
 * 利润永不为正，所以返回 -1 。
 *
 *
 * 提示：
 *
 * n == customers.length
 * 1 <= n <= 105
 * 0 <= customers[i] <= 50
 * 1 <= boardingCost, runningCost <= 100
 * 通过次数10,441提交次数21,426
 */
public class _1599_MaximumProfitOfOperatingACentennialWheel {

    /**
     * 方法：模拟
     *
     * 我们直接模拟摩天轮的轮转过程，每次轮转时，累加等待的游客以及新到达的游客，然后最多 4 个人上船，更新等待的游客数和利润，记录最大利润与其对应的轮转次数。
     *
     * “你必须在新游客到来前轮转 i 次”，每一批，摩天轮必须转，哪怕这一批次人数为0，也要安排
     *
     * 作者：lcbin
     * 链接：https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/solution/python3javacgo-yi-ti-yi-jie-mo-ni-by-lcb-6kz7/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param customers
     * @param boardingCost
     * @param runningCost
     * @return
     */
    public int minOperationsMaxProfit(int[] customers, int boardingCost, int runningCost) {
        // maxProfit整个过程中出现的最大利润；ans记录的是出现最大利润时是第几轮
        // currProfit记录安排到当前轮时，获得的利润
        int maxProfit = 0, currProfit = 0, person = 0, n = customers.length;
        int ans = -1;
        // 安排每一批人，“你必须在新游客到来前轮转 i 次”，每一批，摩天轮必须转，空转也要转
        // 直到 等待乘坐的人数person 为0
        // i 指示了到来的人数是第几批，i+1 代表了当前摩天轮安排到了第几轮（每一批人来都要安排摩天轮，即使来的人数是0）
        // 下标从0开始，和实际计数差1
        for (int i = 0; i < n || person > 0; ++i) {
            // 累加等待乘坐的人
            person += i < n ? customers[i] : 0;
            // 多于4人
            if (person > 4) {
                // 一次安排4个人，计算利润，更新人数
                currProfit += 4 * boardingCost - runningCost;
                person -= 4;
            // 少于四人
            } else {
                // 一次乘坐完，计算利润
                currProfit += person * boardingCost - runningCost;
                // 更新人数
                person = 0;
            }
            // 如果安排到当前轮获得的利润 > 整个过程中能得到的最大利润
            if (currProfit > maxProfit) {
                // 更新最大利润和对应轮数
                maxProfit = currProfit;
                ans = i + 1;
            }
        }
        // 返回 整个过程中 获得最大利润时 是哪一轮
        return ans;
    }
}
