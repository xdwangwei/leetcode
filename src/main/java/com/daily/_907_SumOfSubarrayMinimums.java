package com.daily;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * @author wangwei
 * @date 2022/10/28 17:54
 * @description: _907_SumOfSubarrayMinimums
 *
 * 907. 子数组的最小值之和
 * 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。
 *
 * 由于答案可能很大，因此 返回答案模 10^9 + 7 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：arr = [3,1,2,4]
 * 输出：17
 * 解释：
 * 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。
 * 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
 * 示例 2：
 *
 * 输入：arr = [11,81,94,43,3]
 * 输出：444
 *
 *
 * 提示：
 *
 * 1 <= arr.length <= 3 * 104
 * 1 <= arr[i] <= 3 * 104
 */
public class _907_SumOfSubarrayMinimums {


    /**
     * 题目分析
     * 给定一个数组A，求该数组的所有连续子数组的最小值的总和。
     *
     * 举个例子：比如A=[3,1,2,4]，
     * 所有连续子数组分别为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]，
     * 对应子数组的最小值分别为3，1，2，4，1，1，2，1，1，1，总和为17。
     *
     * 解题思路1：暴力（动态规划）
     *
     * 这是最朴素也是最直观的解法，既然让我们要求每个子数组的最小值，那么直接枚举出所有子数组即可。
     * 两层循环，外层控制子数组的起始位置，内层控制子数组的结束位置。
     * 然后求出每个数组的最小值，求和即可。
     *
     * 时间复杂度：两层循环O(n^2),空间复杂度：O(1)
     *
     * 为何超时？n题目中最大为3∗10^4，n^2 已接近 10^9 且有 MOD 运算，因此必然会超时。
     *
     *
     * 解题思路2：单调栈+贡献值
     *
     * 根据上面的O(n^2)暴力解法，我们需要优化时间复杂度。如何优化呢？下面考虑一个事实：
     * 最小值是在一段连续数字中被筛选出来的，也就是说每个最小值都有一定的辐射范围。
     * 假设给定数组A=[3,1,2,4,1]，在一段连续数字3、1、2、4、1中，只要其中一段数字包含1，那么这段数字的最小值肯定为1，
     * 例如[3,1,2,4,1]、[3,1,2,4]、[3,1,2]、[1,2]等最小值都为1，我们把这叫做元素1的辐射范围。
     *
     *
     * 提示 1：计算以 arr[i] 为最小值的子数组的个数
     *
     * 换个视角，对每个数，算出它是哪些子数组的最小值。
     *
     * 例如 arr=[1,4,2,3,1]，其中 2 是子数组 [2],[4,2],[2,3],[4,2,3] 的最小值，
     * 那么 2 对答案的贡献就是 2*4=8。
     *
     * 由于以 2 为最小值的子数组，绝对不能包含比 2 小的数字，因此我们可以找到 2 左右两侧比它小的数的下标，从而确定子数组的边界。
     * 2 对应的边界为开区间 (0,4)，即闭区间 [1,3]，只要在闭区间 [1,3] 范围内且包含下标 2 的子数组，就是以 2 为最小值的子数组。
     *
     * 一般地，设 arr[i] 对应的边界为开区间 (L,R)，由于子数组必须包含 arr[i]：
     *
     * 子数组的左端点可以是 L+1,L+2,⋯,i，共有 i−L 个；
     * 子数组的右端点可以是 i,i+1,⋯,R−1，共有 R−i 个。
     *
     * 因此，在 arr 【不含重复元素的前提】下，根据乘法原理，我们可以得出如下结论：
     *
     * 以 arr[i] 为最小值的子数组的个数为 (i−L)*(R−i)，
     * 对答案的贡献为 arr[i]*(i−L)*(R−i)。
     *
     * 注：如果左侧没有比 arr[i] 小的元素，则 L=−1；如果右侧没有比 arr[i] 小的元素，则 R=n。
     *
     * 问题转换为寻找原数组中每个元素左边和右边第一个小于自己的索引位置，下文讨论的边界均指的是开区间 (L,R)。
     *
     * 提示 2：修改边界定义，避免重复统计子数组
     *
     * 如果 r 有重复元素，例如 arr=[1,2,4,2,3,1]，其中第一个 2 和第二个 2 对应的边界都是开区间 (0,5)，
     * 子数组 [2,4,2,3] 都包含这两个 2，这样在计算答案时就会重复统计同一个子数组，算出错误的结果。
     *
     * 为避免重复统计，可以修改边界的定义，把右边界改为「找小于或等于 arr[i] 的数的下标」，那么：
     *
     * 第一个 2 对应的边界是 (0,3)，子数组需要在 (0,3) 范围内且包含下标 1；
     * 第二个 2 对应的边界是 (0,5)，子数组需要在 (0,5) 范围内且包含下标 3。
     * 这样以第一个 2 为最小值的子数组，就不会「越界」包含第二个 2 了，从而解决了重复统计子数组的问题。
     *
     * 注：也可以把左边界改为 ≤，右边界不变（仍为 <）。根据对称性，算出来的答案是一样的。
     * 但不能同时将二者都改为 <=，这样会导致二者都未对某个子数组产生贡献
     * 比如上面的例子，如果改为分别寻找左右第一个小于等于的位置，那么
     *      第一个 2 对应的边界是 (0,3)，子数组需要在 (0,3) 范围内且包含下标 1；
     *      第二个 2 对应的边界是 (1,5)，子数组需要在 (1,5) 范围内且包含下标 3。
     *      这样导致二者均为对[1,3]这个子数组产生贡献
     *
     * 提示 3：高效计算边界
     * 最后需要解决的问题是，如何高效计算每个 arr[i] 对应的左右边界？
     *
     * 在给定序列中，找到任意 a[i] 最近一个比其大/小的位置，可使用「单调栈」进行求解。
     *
     * 以计算左边界为例，从左到右遍历 arr，同时用某个合适的数据结构维护遍历过的元素，并及时移除无用的元素，
     * 假如 当前元素是a[i]，之前元素是 a[j]，如果 a[j] >= a[i]，那么它不可能是a[i]的左边界，弹它，直到遇到 a[?]< a[i]
     *      对于后面的元素x来说，如果 x > a[i]，那么 i 就是它的左边界，因此 a[i]弹出的那些东西对它没影响
     *                       如果 x <= a[i]，那么 那么 i 不会是它的左边界，i 之前那些比 a[i] 大的也不会是它的左边界
     *                       所以 弹出左边那些比a[i]大的东西是没错的
     *
     *    移除无用元素后，再把 arr[i] 加到这个数据结构中。因为我们需要直到边界的位置，也就是索引，所以记录的元素都是索引
     *
     * 可以看到，每次弹栈操作相当于保证了数据结构中的元素会形成一个递增的序列，
     * 而对于当前来说，我们移除的已经访问过的元素是数据结构中的最右端的若干元素。
     * 因此我们需要一个数据结构，它支持移除最右端的元素，以及在最右端添加元素，所以它就是栈。
     *
     * 移除栈中 ≥arr[i] 的元素后，栈顶的下标就是 arr[i] 的左边界，如果此时栈为空，那么左边界为 −1。
     *
     * 注 1：在遍历过程中会维护一个栈，移除的是当前的栈顶元素。遍历到 arr[i] 时，arr[i] 及其右侧元素尚未入栈。
     * 注 2：由于栈内元素始终保持单调递增，因此这种数据结构也叫做单调栈。
     *
     * 右边界的计算是类似的，从右往左遍历 arr 可以算出（根据提示 2，需要修改一下比较的符号，具体见代码）。
     *
     * 算出左右边界后，根据提示 1 的公式累加每个 arr[i] 的贡献，即为答案。
     *
     * 代码实现时，有三种实现版本。注意实际入栈的是元素的下标。
     *
     * 作者：endlesscheng
     * 链接：https://leetcode.cn/problems/sum-of-subarray-minimums/solution/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param arr
     * @return
     */
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        // 设 arr[i] 对应的边界为开区间 (L,R)，那么 arr[i] 对答案的贡献为 arr[i]*(i−L)*(R−i)。
        // left[i] 代表 i 左边第一个 <= arr[i] 的元素位置
        // right[i] 代表 i 右边第一个 > arr[i] 的元素位置，二者不同时取等
        int[] left = new int[n];
        int[] right = new int[n];
        // 栈结构，求左右边界
        Deque<Integer> stack = new ArrayDeque<>();
        // 求左边界
        for (int i = 0; i < n; ++i) {
            // 弹出i左边所有 >= arr[i] 的元素
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            // 此时的栈顶就是 arr[i] 左边界，如果栈空，标记为-1
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            // 当前索引入栈
            stack.push(i);
        }
        // 清空栈
        stack.clear();
        // 求右边界，此时时从右往左遍历
        for (int i = n - 1; i >= 0; --i) {
            // 弹出i右边所有 > arr[i] 的元素，上面取等，这里不取等
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                stack.pop();
            }
            // 此时的栈顶就是 arr[i] 右边界，如果栈空，标记为 n
            right[i] = stack.isEmpty() ? n : stack.peek();
            // 当前索引入栈
            stack.push(i);
        }
        // 统计每个元素的贡献，注意 arr[i] * (i - left[i]) * (right[i] - i) 可能溢出
        int ans = 0, mod = (int)(1e9 + 7);
        for (int i = 0; i < n; ++i) {
            ans = (int)((ans + (long)arr[i] * (i - left[i]) * (right[i] - i)) % mod);
        }
        return ans;
    }

    /**
     * 优化：
     * 可以看到，在上面的第一个for循环中，求出了每个元素的左边界，
     * 在第二个for循环中，求出了每个元素的右边界，并且后序没有改动，那么此时已经可以计算当前元素的贡献值了
     * 并且，当前元素的有边界和之前元素的有边界并没有关系，因此我们没必要记录所有元素的有边界
     * 只需要一个变量来迭代就可以了
     * @param arr
     * @return
     */
    public int sumSubarrayMins2(int[] arr) {
        int n = arr.length;
        // 设 arr[i] 对应的边界为开区间 (L,R)，那么 arr[i] 对答案的贡献为 arr[i]*(i−L)*(R−i)。
        // left[i] 代表 i 左边第一个 <= arr[i] 的元素位置
        // right[i] 代表 i 右边第一个 > arr[i] 的元素位置，二者不同时取等
        int[] left = new int[n];
        int[] right = new int[n];
        // 栈结构，求左右边界
        Deque<Integer> stack = new ArrayDeque<>();
        // 求左边界
        for (int i = 0; i < n; ++i) {
            // 弹出i左边所有 >= arr[i] 的元素
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            // 此时的栈顶就是 arr[i] 左边界，如果栈空，标记为-1
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            // 当前索引入栈
            stack.push(i);
        }
        // 清空栈
        stack.clear();
        int ans = 0, mod = (int)(1e9 + 7);
        // 再求有边界的同时计算当前元素的贡献值，更新答案
        for (int i = n - 1; i >= 0; --i) {
            // 弹出i右边所有 > arr[i] 的元素，上面取等，这里不取等
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                stack.pop();
            }
            // 此时的栈顶就是 arr[i] 右边界，如果栈空，标记为 n
            right[i] = stack.isEmpty() ? n : stack.peek();
            // 计算当前元素的贡献值
            ans = (int)((ans + (long)arr[i] * (i - left[i]) * (right[i] - i)) % mod);
            // 当前索引入栈
            stack.push(i);
        }
        return ans;
    }


    /**
     * 优化：
     *
     * 我们求左边界的时候会将每个大于当前元素arr[i]的元素出栈以向左求解得到第一个小于arr[i]的元素，
     * 那么反过来针对每个出栈的元素，当前元素arr[i]不就是向右比它更小的第一个元素吗？这就得到了右边界。
     *
     * 再观察入栈顺序：每个大于当前元素arr[i]的元素出栈完后的 栈顶元素 就是 当前元素的左边界
     *
     * 那么对于每个要出栈的栈顶元素来说，它下面的元素不就是它的左边界吗？这就得到了左边界。
     *
     * 既然左右边界都能在一次遍历中得到，那么自然我们可以一次遍历就得到贡献值，且无需额外空间。
     *
     * 唯一问题是：遍历到最后一个元素时，它能够让它前面的元素都出栈，并计算出它们的贡献值，但它自己的贡献值怎么办呢？
     * 考虑到arr数组中所有元素都是大于0的，那么我们多进行一次循环，虚拟一个元素0入栈，相当于最后一个元素的右边界，所以也就都会被执行出栈操作了。
     *
     * 作者：endlesscheng
     * 链接：https://leetcode.cn/problems/sum-of-subarray-minimums/solution/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param arr
     * @return
     */
    public int sumSubarrayMins3(int[] arr) {
        int n = arr.length;
        // 设 arr[i] 对应的边界为开区间 (L,R)，那么 arr[i] 对答案的贡献为 arr[i]*(i−L)*(R−i)。
        // left[i] 代表 i 左边第一个 <= arr[i] 的元素位置
        // right[i] 代表 i 右边第一个 > arr[i] 的元素位置，二者不同时取等
        Deque<Integer> stack = new ArrayDeque<>();
        int ans = 0, mod = (int)(1e9 + 7);
        // 计算左边界，同时计算右边界，同时计算贡献值
        // 多进行一次循环，是为了让最后一个元素的贡献值也能得到计算
        for (int i = 0; i <= n; ++i) {
            int num = i < n ? arr[i] : 0;
            // 弹出i左边所有 >= arr[i] 的元素
            while (!stack.isEmpty() && arr[stack.peek()] >= num) {
                // 对于弹出的每一个栈顶，当前元素就是它的右边界
                int cur = stack.pop();
                int right = i;
                // 栈顶下面第一个元素就是它的左边界，
                int left = stack.isEmpty() ? -1 : stack.peek();
                // 直接计算它的贡献值
                ans = (int)((ans + (long)arr[cur] * (cur - left) * (right - cur)) % mod);
            }
            // 当前索引入栈
            stack.push(i);
        }
        return ans;
    }
}
