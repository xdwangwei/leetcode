package com.daily;

/**
 * @author wangwei
 * @date 2022/11/21 10:35
 * @description: _808_SoupServings
 *
 * 808. 分汤
 * 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：
 *
 * 提供 100ml 的 汤A 和 0ml 的 汤B 。
 * 提供 75ml 的 汤A 和 25ml 的 汤B 。
 * 提供 50ml 的 汤A 和 50ml 的 汤B 。
 * 提供 25ml 的 汤A 和 75ml 的 汤B 。
 * 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
 *
 * 注意 不存在先分配 100 ml 汤B 的操作。
 *
 * 需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。
 *
 *
 *
 * 示例 1:
 *
 * 输入: n = 50
 * 输出: 0.62500
 * 解释:如果我们选择前两个操作，A 首先将变为空。
 * 对于第三个操作，A 和 B 会同时变为空。
 * 对于第四个操作，B 首先将变为空。
 * 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
 * 示例 2:
 *
 * 输入: n = 100
 * 输出: 0.71875
 *
 *
 * 提示:
 *
 * 0 <= n <= 109
 */
public class _808_SoupServings {

    /**
     * 方法一：动态规划
     * 思路与算法
     *
     * 首先，由于n最大取值为10^9，而四种分配操作都是 25 的倍数，因此我们可以将 n 除以 25（如果有余数，则补 1），
     * 则四种分配操作变为 (4,0),(3,1),(2,2),(1,3)，且每种操作的概率均为 0.25。
     *
     * 当 n 较小时，我们可以用动态规划来解决这个问题。
     * 设 dp(i,j) 表示 汤 A 和 汤 B 分别剩下 i 和 j 份时 题目所求 的 概率值，即汤 A 先分配完的概率 + 汤 A 和汤 B 同时分配完的概率除以 2 。
     *
     * 状态转移方程为：
     *
     * 当前有四种分配方式，选择任何一种都可以得到最终的目标概率，四种结果相加，但要注意每种选择的概率都为0.25，
     * dp(i,j) = 0.25 × ( dp(i−4,y) + dp(i−3,y−1) + dp(i−2,y−2) + dp(i−1,y−3) )
     *
     * 我们仔细考虑一下边界条件：
     *
     * 当满足 i>0,j=0，汤 A 还先分配完的概率为0，汤 A 汤B同时分配完的概率为0，此时 dp(i,j)=0；
     *
     * 当满足 i=0,j=0，此时汤 A 和汤 B 同时分配完的概率为 1.0，汤 A 先分配完的概率为 0，因此 dp(i,j)= 0 + 1.0 / 2=0.5；
     *
     * 当满足 i=0,j>0，汤 A 先分配完的概率为 1.0，汤 A 和汤 B 同时分配完的概率为0，因此 dp(i,j)=1.0；
     *
     * 因此综上，我们可以得到边界条件如下：
     *     i>0,j=0，dp(i,j)=0
     *     i=0,j=0，dp(i,j)=0.5
     *     i=0,j>0，dp(i,j)=1.0
     *
     * 我们可以看到这个动态规划的时间复杂度是 O(n^2)，即使将 n 除以 25 之后，仍然没法在短时间内得到答案，因此我们需要尝试一些别的思路。
     *
     * 【概率论】
     * 我们可以发现，每次分配操作有 (4,0),(3,1),(2,2),(1,3) 四种，
     * 那么在一次分配中，汤 A 平均会被分配的份数期望为 E(A) = (4 + 3 + 2 + 1) * 0.25 = 2.5
     *              ，汤 BB 平均会被分配的份数期望为 E(B) = (0 + 1 + 2 + 3) * 0.25 = 1.5
     *        因此在 n 非常大的时候，汤 A 会有很大的概率比 B 先分配完，
     *        这种情况下，汤 A 被先取完的概率应该非常接近 1，而汤A汤B同时被分完的概率接近0，此时的结果就可以返回1
     *
     *        事实上，当我们进行实际计算时发现，当 n≥4451 时，所求概率已经大于 0.99999 了（可以通过上面的动态规划方法打标求出），
     *        它和 1 的误差（无论是绝对误差还是相对误差）都小于 10^{-5}
     *
     * 实际我们在进行测算时发现：
     *
     * n = 4450, p = 0.9999893866772255
     * n = 4451, p = 0.9999902113072541
     * n = 4452, p = 0.9999902113072541
     *
     * 因此在 n ≥ 4451 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/soup-servings/solution/fen-tang-by-leetcode-solution-0yxs/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @return
     */
    public double soupServings(int n) {
        // 当 n≥4451 时，所求概率已经大于 0.99999 了，这是先写完动态规划打表发现的结论，结合题目和概率论知识得到验证
        if (n >= 4451) {
            return 1.0;
        }
        // 分配是以25为单位，因此，缩小数据范围，降低时间复杂度
        n = (int)(Math.ceil(n * 1.0 / 25));
        // dp(i,j) 表示 汤 A 和 汤 B 分别剩下 i 和 j 份时 题目所求 的 概率值
        double[][] dp = new double[n + 1][n + 1];
        // A和B都为0时，二者同时分配完的概率是1，A比B先分配完的概率是0，结果是 0 + 1/2 = 0.5
        dp[0][0] = 0.5;
        // A为0，B > 0 时，A比B先分配完的概率是1，二者同时分配完的概率是0，，结果是 1 + 0/2 = 0
        for (int i = 1; i <= n; ++i) {
            dp[0][i] = 1;
        }
        // 递推 。A 为 i，B 为 j
        for (int i = 1; i <= n; ++i) {
            // i>0,j=0，A先分配完概率为0，AB同时分配完概率为0，此时 dp(i,j)=0；
            for (int j = 1; j <= n; ++j) {
                // 可以选择四种分配方式的任何一种，每种选择概率是0.25，四种结果累加，注意下标取值范围
                dp[i][j] = 0.25 * (dp[Math.max(0, i - 4)][j] + dp[Math.max(0, i - 3)][j - 1] + dp[Math.max(0, i - 2)][Math.max(0, j - 2)] + dp[i - 1][Math.max(0, j - 3)]);
            }
        }
        // 返回
        return dp[n][n];
    }

    public static void main(String[] args) {
        _808_SoupServings obj = new _808_SoupServings();
        for (int i = 1000; i < 10000000; ++i) {
            double ans = obj.soupServings(i);
            if (ans > 0.9999) {
                System.out.println(i + ", " + ans);
            }
        }
    }
}
