package com.daily;

/**
 * @author wangwei
 * @date 2022/10/20 11:09
 * @description: _779_KthSymbolInGrammar
 *
 * 779. 第K个语法符号
 * 我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
 *
 * 例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。
 * 给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）
 *
 *
 * 示例 1:
 *
 * 输入: n = 1, k = 1
 * 输出: 0
 * 解释: 第一行：0
 * 示例 2:
 *
 * 输入: n = 2, k = 1
 * 输出: 0
 * 解释:
 * 第一行: 0
 * 第二行: 01
 * 示例 3:
 *
 * 输入: n = 2, k = 2
 * 输出: 1
 * 解释:
 * 第一行: 0
 * 第二行: 01
 *
 *
 * 提示:
 *
 * 1 <= n <= 30
 * 1 <= k <= 2n - 1
 * 通过次数27,850提交次数60,066
 */
public class _779_KthSymbolInGrammar {


    /**
     * 正向找规律 + 递归
     * 思路与算法
     *
     * 尝试写表中的前几行：
     *
     * 00
     * 0101
     * 01100110
     * 0110100101101001
     * ....
     * 我们可以注意到规律：每一行的后半部分正好为前半部分的“翻转”
     *      前半部分是 0 后半部分变为 1，前半部分是 1，后半部分变为 0。
     *      且每一行的前半部分和上一行相同。
     *      我们可以通过「数学归纳法」来进行证明。
     *
     * n 和 k 都是从1开始，第 n 行的字符个数 = 2 ^ n-1, 一半字符数是 2 ^ n-2
     *
     *
     * 有了这个性质，那么我们再次思考原问题：对于查询某一个行第 k 个数字，如果 k 在后半部分，那么原问题就可以转化为求解该行前半部分的对应位置的“翻转”数字，又因为该行前半部分与上一行相同，所以又转化为上一行对应对应的“翻转”数字。那么按照这样一直递归下去，并在第一行时返回数字 0 即可。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/di-kge-yu-fa-fu-hao-by-leetcode-solution-zgwd/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @param k
     * @return
     */
    public int kthGrammar(int n, int k) {
        // 第一行，或者每一行的第1个字符都是0
        if (k == 1) {
            return 0;
        }
        // 当前行字符个数  = 2 ^ n-1, 一半字符数是 2 ^ n-2
        // k <= 一半，前半部分和上一行一样
        if (k <= (1 << n - 2)) {
            return kthGrammar(n - 1, k);
        }
        // 后半部分，来自于上一行前半部分的反转，所以要异或1
        return kthGrammar(n - 1, k - (1 << n - 2)) ^ 1;
    }

    /**
     * 逆向倒推+递归
     * 思路与算法
     *
     * 比如当 n=3 时，第 1 行是 0，第 2行是 01，第 3 行是 0110。
     *
     * 现在要求表第 n 行中第 k 个数字，1≤k≤2n
     *
     * 首先我们可以看到第 i 行中会有 2^{i-1}数字，1 ≤ i ≤ n，且其中第 j 个数字按照构造规则会生第 i+1 行中的第 2∗j−1 和 2∗j 个数字，1 ≤ j ≤ 2^{i-1}
     * 即对于第 i+1 行中的第 k 个数字 num1，1 ≤ x ≤ 2^i，会被第 i 行中第 (k+1)/2 个数字 nums2 生成。且满足规则：
     *
     * 当 nums2 = 0 时，会生成 01:
     *      如果num1在奇数位置，也就是nums2生成的第一个位置（k & 1 == 1），那么 nums1=0
     *      如果num1在偶数位置，也就是nums2生成的第二个位置（k & 1 == 0），那么 nums1=1
     * 当 nums2 = 1 时，会生成 10:
     *      如果num1在奇数位置，也就是nums2生成的第一个位置（k & 1 == 1），那么 nums1=1
     *      如果num1在偶数位置，也就是nums2生成的第二个位置（k & 1 == 0），那么 nums1=0
     *
     * 真值表
     *
     *      num2     k&1      -->       nums1
     *      0         1                   0
     *      0         0                   1
     *      1         1                   1
     *      1         0                   0
     *
     * 结我们可以得到：nums1 = nums2 ⊕ (k&1) ⊕ 1 ，其中 & 为「与」运算符， ⊕ 为「异或」运算符。
     * 那么我们从第 n 不断往上递归求解，并且当在第一行时只有一个数字，直接返回 0 即可。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/di-kge-yu-fa-fu-hao-by-leetcode-solution-zgwd/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @param k
     * @return
     */
    public int kthGrammar2(int n, int k) {
        // 第一行，或者每一行的第1个字符都是0
        if (k == 1) {
            return 0;
        }
        // 第 i+1 行中的第 k 个数字 num1，，会被第 i 行中第 (k+1)/2 个数字 nums2 生成。
        // nums1 = (k&1) ⊕ nums2 ⊕ 1
        return 1 ^ (k & 1) ^ kthGrammar(n - 1, (k + 1) / 2);
    }
}
