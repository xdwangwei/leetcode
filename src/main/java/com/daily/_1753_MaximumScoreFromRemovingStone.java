package com.daily;

/**
 * @author wangwei
 * @date 2022/12/21 14:58
 * @description: _1753_MaximumScoreFromRemovingStone
 *
 * 1753. 移除石子的最大得分
 * 你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c 的 三堆 石子。
 *
 * 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
 *
 * 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
 *
 *
 * 示例 1：
 *
 * 输入：a = 2, b = 4, c = 6
 * 输出：6
 * 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：
 * - 从第一和第三堆取，石子状态现在是 (1, 4, 5)
 * - 从第一和第三堆取，石子状态现在是 (0, 4, 4)
 * - 从第二和第三堆取，石子状态现在是 (0, 3, 3)
 * - 从第二和第三堆取，石子状态现在是 (0, 2, 2)
 * - 从第二和第三堆取，石子状态现在是 (0, 1, 1)
 * - 从第二和第三堆取，石子状态现在是 (0, 0, 0)
 * 总分：6 分 。
 * 示例 2：
 *
 * 输入：a = 4, b = 4, c = 6
 * 输出：7
 * 解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是：
 * - 从第一和第二堆取，石子状态现在是 (3, 3, 6)
 * - 从第一和第三堆取，石子状态现在是 (2, 3, 5)
 * - 从第一和第三堆取，石子状态现在是 (1, 3, 4)
 * - 从第一和第三堆取，石子状态现在是 (0, 3, 3)
 * - 从第二和第三堆取，石子状态现在是 (0, 2, 2)
 * - 从第二和第三堆取，石子状态现在是 (0, 1, 1)
 * - 从第二和第三堆取，石子状态现在是 (0, 0, 0)
 * 总分：7 分 。
 * 示例 3：
 *
 * 输入：a = 1, b = 8, c = 8
 * 输出：8
 * 解释：最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。
 * 注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。
 *
 *
 * 提示：
 *
 * 1 <= a, b, c <= 105
 * 通过次数17,736提交次数25,677
 */
public class _1753_MaximumScoreFromRemovingStone {

    /**
     * 本题可以使用贪心法解题，贪心策略如下：
     * 我们首先假设 a <= b <= c
     *   为了使分数最大化，必须让减少操作进行最多回合，最优策略就是让最大的堆能够减少到0
     *      当a + b <= c时，此时c不可能减少到0了，那就尽力让a、b以最慢的速度最终都变为0
     *          最优策略为：每次取石子，都从c中取一颗，再到a或b中取一颗，最终a、b全被消耗完，操作次数为 a + b
     *          此时分数为 a + b
     *      当a + b > c时，为了尽可能让c堆能够减为0，先利用a和b去消耗c，若最后a、b还有剩余，再在a、b间操作
     *          最优策略为：每次取石子，先从c中取一颗，再从a和b中较大的取一颗，这样将c取完后，a和b的值必然相等或差1，最后从a、b中取石子。
     *          此时分数为 c + (a + b - c) / 2 = (a + b + c) / 2。
     *
     *          这种情况下，为什么不采用以下策略：先用a消耗c，然后用一部分b把剩下的c消耗完，也能达到消耗完c的目的？
     *          这种情况下b会有大量剩余，而此时a、c已经变为0，从而这部分被浪费，
     *          而在最优策略下，当c被消耗完时，a、b均未成0，并且差值不到1，仍能进行后序减少操作，肯定由于上面情况
     *
     * 作者：lcfgrn
     * 链接：https://leetcode.cn/problems/maximum-score-from-removing-stones/solution/by-lcfgrn-mgga/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param a
     * @param b
     * @param c
     * @return
     */
    public int maximumScore(int a, int b, int c) {
        // 求和
        int sum = a + b + c;
        // 求最大值
        int max = Math.max(Math.max(a, b), c);
        // 两个较小值的和
        int leftTwoSum = sum - max;
        // 分情况
        return leftTwoSum <= max ? leftTwoSum : sum / 2;
    }
}
