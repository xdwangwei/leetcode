package com.daily;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author wangwei
 * @date 2022/12/10 10:55
 * @description: _1691_MaximumHeightByStackingCuboids
 *
 * 1691. 堆叠长方体的最大高度
 * 给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。
 *
 * 如果 widthi <= widthj 且 lengthi <= lengthj 且 heighti <= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。
 *
 * 返回 堆叠长方体 cuboids 可以得到的 最大高度 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]
 * 输出：190
 * 解释：
 * 第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。
 * 第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。
 * 第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。
 * 总高度是 95 + 50 + 45 = 190 。
 * 示例 2：
 *
 * 输入：cuboids = [[38,25,45],[76,35,3]]
 * 输出：76
 * 解释：
 * 无法将任何长方体放在另一个上面。
 * 选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。
 * 示例 3：
 *
 * 输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
 * 输出：102
 * 解释：
 * 重新排列长方体后，可以看到所有长方体的尺寸都相同。
 * 你可以把 11x7 的一面朝下，这样它们的高度就是 17 。
 * 堆叠长方体的最大高度为 6 * 17 = 102 。
 *
 *
 * 提示：
 *
 * n == cuboids.length
 * 1 <= n <= 100
 * 1 <= widthi, lengthi, heighti <= 100
 * 通过次数5,245提交次数9,175
 */
public class _1691_MaximumHeightByStackingCuboids {


    /**
     * 动态规划 O(36n^2))
     *
     * 因为每个箱子可以旋转，我们其实将箱子旋转后的结果作为一个新箱子加入到这个数组中，每个箱子的旋转结果有3! = 6 种
     * 但对于旋转后的六种结果，需要一定的判断，比如不能重复添加：
     *      如果长宽高都相同，其实就没必要也不能进行旋转，因为旋转后的箱子是一样的，会放在自己上面，就错啦。
     *      如果长宽高都不同，那么旋转后肯定不可放在自己上（没办法满足长宽高同时满足小于等于旋转前的长宽高），不会造成重复选择。
     *      假设长宽相同，
     *          交换宽高没意义，会导致得到的新的箱子能放在自己上面，结果错误
     *          可以把宽高交换或者是长高交换，交换后同样不可能放在自己上面。
     *              比如 (a,a,b)->(a,b,a) 因为 宽约束(a <= b) 和 高约束(b <= a) 不可能同时满足
     *      对于长高相同或宽高相同情况同理
     *
     *
     * 将所以箱子扩展完以后，问题就变成了从给定的箱子里面选择出能组合成高度最高的。
     *
     * 三维最长上升子序列。
     *
     * 类似于最长递增子序列长度，我们可以设 dp[i] 表示以第 i 个长方体为【最底层】长方体时得到的最大堆叠高度，
     * 可以使用动态规划并写出状态转移方程：
     *      dp[i] = max(dp[j]) + height_i
     *      其中 j < i，且 width_j <= width_i && length_j <= length_i && height_j <= height_i
     *
     * 我们需要找到找到所有可以放置到 i 长方体之上的长方体 j，长方体 j 需要满足 长宽高分别<= 长方体 i
     * 如果不存在可以堆叠的长方体，此时 dp[i]=height_i
     *
     * 最终最大的堆叠高度即为 max(dp[i])。
     *
     * 但是，为了保证上述的动态规划的正确性，必须保证当枚举到第 i 个长方体时，所有可以堆叠在第 i 个长方体之上的长方体都应该枚举过，
     * 因此在动态规划之前，我们应保证所有满足可堆叠在第 i 个长方体之上的长方体j排在 i 之前，
     * 可以利用排序来解决这个问题。那么排序规则按照长宽高依次从小到大。
     *
     *
     * 数据规模从 n 变为 6n，时间复杂度从 n^2 变为 (6n)^2 = 36n^2
     *
     * 作者：Florescent
     * 链接：https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution/by-florescent-ljum/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param cuboids
     * @return
     */
    public int maxHeight(int[][] cuboids) {
        // 新的方块列表
        List<int[]> list = new ArrayList<>();
        // 枚举每个方块所有可能的选中结果，加入list
        for (int[] cuboid : cuboids) {
            // 加入自己
            list.add(cuboid);
            int w = cuboid[0], l = cuboid[1], h = cuboid[2];
            // 长宽高相等，没有旋转必要
            if (w == l && l == h) {
                continue;
            }
            // 长宽相等，可以 交换 长高 或 宽高
            if (w == l) {
                list.add(new int[]{w, h, l});
                list.add(new int[]{h, l, w});
            // 宽高相等，可以 交换 长宽 或 长高
            } else if (w == h) {
                list.add(new int[]{l, w, h});
                list.add(new int[]{w, h, l});
            // 长高相等，可以 交换 长宽 或 宽高
            } else if (l == h) {
                list.add(new int[]{l, w, h});
                list.add(new int[]{h, l, w});
            // 长宽高均不相等，可以 交换长宽、长高 或 宽高。。全排列，除掉本身
            } else {
                list.add(new int[]{w, h, l});
                list.add(new int[]{l, w, h});
                list.add(new int[]{l, h, w});
                list.add(new int[]{h, l, w});
                list.add(new int[]{h, w, l});
            }
        }
        // 对所有方块进行排序，保证遍历到方块i时，所有能放置在i上的方块只可能出现在i之前
        // 等价于按体积排序
        // 注意这里并不是说排序后，i前面所有方块都能放在i上面，只能保证i后面所有方块都不可能放在i上面
        // 对于i前面的方块，只能说他们的宽度一定是小于等于i的
        list.sort((c1, c2) -> {
            if (c1[0] != c2[0]) {
                return c1[0] - c2[0];
            }
            if (c1[1] != c2[1]) {
                return c1[1] - c2[1];
            }
            return c1[2] - c2[2];
        });
        // 动态规划
        // dp[i] 表示以第 i 个长方体为【最底层】长方体时得到的最大堆叠高度，
        int n = list.size();
        int[] dp = new int[n];
        int ans = 0;
        // 对于方块i
        for (int i = 0; i < n; ++i) {
            int[] cur = list.get(i);
            // 初始化dp[i]为自己的高度
            dp[i] = cur[2];
            // 遍历它前面已经访问过的方块
            for (int j = 0; j < i; ++j) {
                int[] pre = list.get(j);
                // 找到能够放置在它上面的方块
                // 本来要满足宽、长、高 都不超过自己
                // 因为dp前所有方块的排序规则中，宽是第一个排序维度，所以已经符合要求了
                if (pre[1] <= cur[1] && pre[2] <= cur[2]) {
                    // 枚举选择将这些块放置在i上，能得到的最大高度
                    dp[i] = Math.max(dp[i], dp[j] + cur[2]);
                }
            }
            // ans 是 所有 可能结果中的最大值
            ans = Math.max(ans, dp[i]);
        }
        // 返回
        return ans;
    }


    /**
     * 方法一时间复杂度太高，花费34ms，只击败 7%，当题目规模 n 超过 100 时，可能无法通过全部测试用例
     * 方法一最大的问题，在于对每个箱子枚举了它所有的可能结果，导致时间复杂度太高
     * 我们的目的是有效的减少甚至省去这个过程。、
     *
     * 由于题目要求长方体的高度最大，直观上会想到将每个长方体的最长边做为高度是最优的，因此我们需要验证这种堆叠方法是否正确。
     * 就是说，需要判断，当 c1 能够放在 c2上时，如果 把 c1 和 c2旋转，让 最长的边作为高时，得到的 c1' 是否 仍然能 放在c2' 上
     *
     * 假设两个长方体 c1, c2 的长宽高分别为 (w1,l1,h1) 与 (w2,l,h2)
     * 且满足 w1 <= w2, l1 <= l2, h1 <= h2，此时长方体 c1 一定可以堆叠在长方体 c2之上，
     * 此时得到的高度为 h1 + h2
     *
     * 我们将长方体 c1, c2 的长宽高按照从小到大的顺序重新进行排列为 (w1',l1',h1')与 (w2',l2',h2')
     * 满足 w1' <= l1' <= h1', w2' <= l2' <= h2'
     * 此时我们只需要证明 w1' <= w2', l1' <= l2', h1' <= h2'，即可满足堆叠条件。
     * 
     * 证明如下：
     *      旋转前，w1 <= w2, l1 <= l2, h1 <= h2
     *      那么， c1 中的最小值 <= c2 中的最小值；c1 中的最大值 <= c2 中的最大值
     *      则，   w1' <= w2', h1' <= h2'
     *      假设   l1' > l2'
     *          那么有  w1' <= w2' <= l2' < l1' <= h1' <= h2'
     *          因为旋转前 c1 能放在 c2上，因此，不论 w2‘ 和 l2’ 来自于 c2 排序前哪个位置，c1 中都应该存在对应位置 <= 它
     *          即，c1‘ 中 必须存在 一个元素 <= w2'，存在另一个元素 < l2'
     *          但是根据上面的等式，此时小于等于 w2',l2' 的元素只有一个，与上述结论相矛盾，
     *          因此假设不成立，我们一定可以得出结论 l1' <= l2' 。
     *
     *     因此 w1' <= w2', l1' <= l2', h1' <= h2' 成立
     *
     * 即：若 c1 能放置在 c2 上，那么 c1、c2按照三条边从小到大排序后得到c1’，c2‘，此时 c1‘仍然能够放在 c2’ 上
     * 反之，如果 c1 重排列后 不能放置在 c2 重排列的方块上，那么 初始时的c1及其变体(他们排列后结果一致)，也没办法放置在c2上
     * 因此我们不必考虑每个正方体所有旋转的情况。
     *
     * 当按照长方体的三条边从小到大进行排序后，此时长方体的高度即对应了三条边中的最大值，那么整个长方体的堆叠高度之和一定不会大于每个长方体的最大边之和，
     * 因此最优的堆叠方法一定是基于最长边作为高度的。
     * （这部分有点贪心思想，能够成立的原因在于题目要求a能放在b上的要求必须同时满足长宽高限制，那么在这种情况下，
     *      假如方块a以最长边作为高时，上面能承载3个块，那么以其他任意一条边作为高时，由于高度限制，上面能够放置的块一定不会超过3个，而此时已经牺牲了一部分高度
     *      因此，以最长边作为高，一定最优）
     *
     * 当前面部分优化完后，剩余步骤和方法一一致
     * 设 dp[i] 表示以第 i 个长方体为【最底层】长方体时得到的最大堆叠高度，
     *      * 可以使用动态规划并写出状态转移方程：
     *      *      dp[i] = max(dp[j]) + height_i
     *      *      其中 j < i，且 width_j <= width_i && length_j <= length_i && height_j <= height_i
     *      *
     *      * 我们需要找到找到所有可以放置到 i 长方体之上的长方体 j，长方体 j 需要满足 长宽高分别<= 长方体 i
     *      * 如果不存在可以堆叠的长方体，此时 dp[i]=height_i
     *      *
     *      * 最终最大的堆叠高度即为 max(dp[i])。
     *      *
     *      * 为了保证上述的动态规划的正确性，必须保证当枚举到第 i 个长方体时，所有可以堆叠在第 i 个长方体之上的长方体都应该枚举过，
     *      * 因此在动态规划之前，我们应保证所有满足可堆叠在第 i 个长方体之上的长方体j排在 i 之前，
     *      * 可以利用排序来解决这个问题。那么排序规则按照长宽高依次从小到大。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution/dui-die-chang-fang-ti-de-zui-da-gao-du-b-17qg/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param cuboids
     * @return
     */
    public int maxHeight2(int[][] cuboids) {
        int n = cuboids.length;
        // 对每个方块进行长宽高重新排列，让最长边作为高
        for (int[] cuboid : cuboids) {
            Arrays.sort(cuboid);
        }
        // 后序步骤与方法一一模一样
        // 对所有方块进行排序，保证遍历到方块i时，所有能放置在i上的方块只可能出现在i之前
        // 等价于按体积排序
        // 注意这里并不是说排序后，i前面所有方块都能放在i上面，只能保证i后面所有方块都不可能放在i上面
        // 对于i前面的方块，只能说他们的宽度一定是小于等于i的
        Arrays.sort(cuboids, (c1, c2) -> {
            // 先按宽度排序
            if (c1[0] != c2[0]) {
                return c1[0] - c2[0];
            }
            // 宽度相等按长度排序
            if (c1[1] != c2[1]) {
                return c1[1] - c2[1];
            }
            // 长度相等按高度排序
            return c1[2] - c2[2];
        });
        // 动态规划
        // dp[i] 表示以第 i 个长方体为【最底层】长方体时得到的最大堆叠高度，
        int[] dp = new int[n];
        int ans = 0;
        // 对于方块i
        for (int i = 0; i < n; ++i) {
            int[] cur = cuboids[i];
            // 初始化dp[i]为自己的高度
            dp[i] = cur[2];
            // 遍历它前面已经访问过的方块
            for (int j = 0; j < i; ++j) {
                int[] pre = cuboids[j];
                // 找到能够放置在它上面的方块
                // 本来要满足宽、长、高 都不超过自己
                // 因为dp前所有方块的排序规则中，宽是第一个排序维度，所以已经符合要求了
                if (pre[1] <= cur[1] && pre[2] <= cur[2]) {
                    // 枚举选择将这些块放置在i上，能得到的最大高度
                    dp[i] = Math.max(dp[i], dp[j] + cur[2]);
                }
            }
            // ans 是 所有 可能结果中的最大值
            ans = Math.max(ans, dp[i]);
        }
        // 返回
        return ans;
    }
}
