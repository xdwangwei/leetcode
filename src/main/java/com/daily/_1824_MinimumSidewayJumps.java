package com.daily;

/**
 * @author wangwei
 * @date 2023/1/21 18:18
 * @description: _1824_MinimumSidewayJumps
 *
 * 1824. 最少侧跳次数
 * 给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。
 *
 * 给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。
 *
 * 比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
 * 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。
 *
 * 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
 * 这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。
 *
 * 注意：点 0 处和点 n 处的任一跑道都不会有障碍。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：obstacles = [0,1,2,3,0]
 * 输出：2
 * 解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。
 * 注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。
 * 示例 2：
 *
 *
 * 输入：obstacles = [0,1,1,3,3,0]
 * 输出：0
 * 解释：跑道 2 没有任何障碍，所以不需要任何侧跳。
 * 示例 3：
 *
 *
 * 输入：obstacles = [0,2,1,0,3,0]
 * 输出：2
 * 解释：最优方案如上图所示。总共有 2 次侧跳。
 *
 *
 * 提示：
 *
 * obstacles.length == n + 1
 * 1 <= n <= 5 * 105
 * 0 <= obstacles[i] <= 3
 * obstacles[0] == obstacles[n] == 0
 * 通过次数17,363提交次数25,837
 */
public class _1824_MinimumSidewayJumps {

    /**
     * 方法一：动态规划
     * 思路与算法
     *
     * 为了方便编写代码，我们用 0,1,2 对跑道进行编号，因此 obstacles[i] - 1 与跑道对应，其为− 1 时表示该点没有障碍。
     *
     * 我们可以使用动态规划来解决本题，设 d[i][j] 表示青蛙到达 i 号点的 j 号跑道时所需要的最少侧跳次数。
     *
     * 初始时，青蛙处于 0 号点的 1 号跑道，因此 d[0][1]=0。
     * 又由于题目保证点 0 处没有障碍，并且青蛙可以通过一次侧跳到达其他跑道，所以 d[0][0] 与 d[0][2] 初始值都为 1。
     *
     * 对于其他状态的默认值我们设置为正无穷。此处的正无穷可以用点的个数n的二倍代替
     *
     * 转移时，我们分两步考虑：
     *
     * 【第一步】
     * 首先，青蛙可以从点 i−1 处直接跳到点 i 处，前提是当前跑道没有障碍，如果有障碍，我们需要单独将其设置为正无穷。
     * 因此，有如下转移方程：
     *      dp[i][j] = dp[i - 1][j],            j != obstacles[i] - 1
     *      dp[i][j] = inf         ,            j == obstacles[i] - 1
     *
     *                                        其中 j ∈ [0,2]。
     * 【第二步】
     * 然后，青蛙可以通过消耗一次侧跳次数从当前跑道跳到另外两条跑道。
     * 反之，对于 i 点 j 跑道，可以 来自于 i 点另外两外跑道通过一次侧跳到达。
     * 对于 j = 0，可以来自于 1、2 跑道
     * 对于 j = 1，可以来自于 0、2 跑道
     * 对于 j = 2，可以来自于 0、1 跑道
     * 即，dp[i][j] 可以 来自于 dp[i][(j+1)%3] + 1, dp[i][(j+2)%3] + 1
     * 当然，j处不能有障碍
     *
     * 因此，有如下转移方程：
     *
     *  d[i][j]=min(d[i][j], min(dp[i][(j+1)%3] + 1, dp[i][(j+2)%3] + 1))
     *
     * 其中 j∈[0,2]，且 j ≠ =obstacles[i]−1。
     *
     * 【注意】
     * 因为侧跳是发生在同一个点的不同跑道上，因此必须先完成步骤一，再完成步骤二，两次dp的迭代更新不可以合并。
     *
     * 经过 n 次转移后， min(d[n][0],d[n][1],d[n][2]) 就是答案。
     *
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/minimum-sideway-jumps/solution/zui-shao-ce-tiao-ci-shu-by-leetcode-solu-3y2g/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param obstacles
     * @return
     */
    public int minSideJumps(int[] obstacles) {
        // obstacles 长度是 n + 1
        int n = obstacles.length - 1;
        int[][] dp = new int[n + 1][3];
        // d[i][j] 表示青蛙到达 i 号点的 j 号跑道时所需要的最少侧跳次数。
        // 初始在0号点1号跑道，且0号点没有障碍物，因此dp[0][1] = 0, dp[0][0] = dp[0][2] = 1
        dp[0][0] = dp[0][2] = 1;
        // 设置一个max，其他dp值默认为man
        int max = 2 * n;
        // 迭代，从1到n
        for (int i = 1; i <= n; ++i) {
            // i点的障碍物位置
            int obs = obstacles[i] - 1;
            // 【第一步】从i-1位置到达i位置
            // 遍历三个跑道
            for (int j = 0; j < 3; ++j) {
                // 有障碍物的跑道，无法到达，
                if (j == obs) {
                    dp[i][j] = max;
                // 没有障碍物。可以从i-1位置到达，不用侧跳
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
            // 【第二步】到达i位置，通过侧跳到达另外两个跑道，或者说通过侧跳从另外两个跑道来到当前跑道
            // 遍历三个通道
            for (int j = 0; j < 3; ++j) {
                // 无障碍物通道，可以通过另外两个通道侧滑过来
                if (j != obs) {
                    // 另外两个通道号
                    int one = (j + 1) % 3, two = (j + 2) % 3;
                    // 迭代更新dp[i][j]
                    dp[i][j] = Math.min(dp[i][j], dp[i][one] + 1);
                    dp[i][j] = Math.min(dp[i][j], dp[i][two] + 1);
                }
            }
        }
        // 返回到达n点，三个通道使用侧滑数最少的通道所需要的侧滑数
        return Math.min(dp[n][0], Math.min(dp[n][1], dp[n][2]));
    }

    /**
     *
     * 方法一优化，滚动数组 空间压缩
     *
     *
     * 不难通过上述转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，
     * 但是由于 d[i] 求解时只利用到了 d[i−1]，并且通过转移方程我们可以发现额外存储 d[i−1] 是没有必要的。
     * 因此，可以利用「滚动数组思想」把空间复杂度优化为 O(1)，在本题中，只需要用一个长度为 3 的数组即可。
     *
     * @param obstacles
     * @return
     */
    public int minSideJumps2(int[] obstacles) {
        // obstacles 长度是 n + 1
        int n = obstacles.length - 1;
        int[] dp = new int[3];
        // d[i][j] 表示青蛙到达 i 号点的 j 号跑道时所需要的最少侧跳次数。
        // 初始在0号点1号跑道，且0号点没有障碍物，因此dp[0][1] = 0, dp[0][0] = dp[0][2] = 1
        dp[0] = dp[2] = 1;
        // 设置一个max，其他dp值默认为man
        int max = 2 * n;
        // 迭代，从1到n
        for (int i = 1; i <= n; ++i) {
            // i点的障碍物位置
            int obs = obstacles[i] - 1;
            // 【第一步】从i-1位置到达i位置
            // 遍历三个跑道
            for (int j = 0; j < 3; ++j) {
                // 有障碍物的跑道，无法到达，
                if (j == obs) {
                    dp[j] = max;
                } /*else {
                    dp[j] = dp[j];
                }*/
            }
            // 【第二步】到达i位置，通过侧跳到达另外两个跑道，或者说通过侧跳从另外两个跑道来到当前跑道
            // 遍历三个通道
            for (int j = 0; j < 3; ++j) {
                // 无障碍物通道，可以通过另外两个通道侧滑过来
                if (j != obs) {
                    // 另外两个通道号
                    int one = (j + 1) % 3, two = (j + 2) % 3;
                    // 迭代更新dp[i][j]
                    dp[j] = Math.min(dp[j], dp[one] + 1);
                    dp[j] = Math.min(dp[j], dp[two] + 1);
                }
            }
        }
        // 返回到达n点，三个通道使用侧滑数最少的通道所需要的侧滑数
        return Math.min(dp[0], Math.min(dp[1], dp[2]));
    }
}
