package com.daily;

/**
 * @author wangwei
 * @date 2022/12/29 16:48
 * @description: _1739_BuildingBoxes
 *
 * 1739. 放置盒子
 * 有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：
 *
 * 你可以把盒子放在地板上的任何地方。
 * 如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。
 * 给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：n = 3
 * 输出：3
 * 解释：上图是 3 个盒子的摆放位置。
 * 这些盒子放在房间的一角，对应左侧位置。
 * 示例 2：
 *
 *
 *
 * 输入：n = 4
 * 输出：3
 * 解释：上图是 3 个盒子的摆放位置。
 * 这些盒子放在房间的一角，对应左侧位置。
 * 示例 3：
 *
 *
 *
 * 输入：n = 10
 * 输出：6
 * 解释：上图是 10 个盒子的摆放位置。
 * 这些盒子放在房间的一角，对应后方位置。
 *
 *
 * 提示：
 *
 * 1 <= n <= 109
 * 通过次数12,279提交次数18,974
 */
public class _1739_BuildingBoxes {


    /**
     * 方法一：数学规律
     *
     * 根据题目描述，为了使接触地面的盒子尽可能少，应堆叠尽可能高，又因为每个盒子上面能够堆叠盒子的条件是四面都有盒子或墙壁，
     * 因此层数最高的盒子需要放在墙角，并且盒子的摆放呈阶梯状，俯视图应该是一个左上等腰三角，这样可以使得接触地面的盒子数量最少。
     *
     * 在这种“紧凑塔形”堆叠情况下：
     * 假设盒子摆放 k 层，从上到下，每一层紧凑摆满，那么个数分别是 1, 1+2, 1+2+3, ..., 1+2+...+k
     *
     * 因为n并不一定能恰好凑出一个紧凑塔形，因此，寻找不超过n的情况下，紧凑塔形的最大高度k
     * 假设此时消耗的总盒子数为 s，
     *      如果 s == n，那么返回底层盒子个数 k(k+1)/2
     *      如果 s < n，此时剩余 left = n - s，我们需要考虑在紧凑塔形的基础上放置这left个盒子
     *
     *      此时考虑在紧凑塔形的基础上，底层每多放置一个盒子时，整体能够多放置几个盒子
     *          （在递增添加新的盒子时，尽量靠近原紧凑塔形的底层盒子，使更多盒子四面都有盒子，从而能够在顶部叠加，使得整体能够容纳更多盒子）
     *          底层多1个，整体能够多1个
     *          底层多2个，整体能够多3个 = 1+2
     *          底层多3个，整体能够多6个 = 1+2+3
     *          底层多4个，整体能够多10个 = 1+2+3+4
     *          ...
     *          我们需要寻找 能够让整体多出left个盒子时，底层最少需要增加的盒子数x
     *          最后返回 k(k+1)/2 + x
     *
     * 如果此时盒子还有剩余，那么可以从最低一层继续摆放，假设摆放 ii 个，那么累计可摆放的盒子个数为 1+2+\cdots+i1+2+⋯+i。
     *
     * https://leetcode.cn/problems/building-boxes/solution/by-lcbin-nbq1/
     * https://leetcode.cn/problems/building-boxes/solution/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-8vbe/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @return
     */
    public int minimumBoxes(int n) {
        int k = 1;
        int s = 0;
        // 寻找不超过n的紧凑塔形的最大层数k
        // 紧凑塔形第i层的盒子个数为 i(i+1)/2
        while (s + k * (k + 1) / 2 < n) {
            s += k * (k + 1) / 2;
            k++;
        }
        // 如果再加一层恰好能凑出塔形，返回底层盒子数量
        if (s + k * (k + 1) / 2 == n) {
            return k * (k + 1) / 2;
        }
        // 否则答案分两部分：紧凑塔形底部盒子数量 + 能够使得整体继续容纳n-s个盒子时所需的至少需要添加的底层盒子数量
        // 注意先把k恢复
        k--;
        // 第一部分，紧凑塔形的底部盒子数量
        int ans = k * (k + 1) / 2;
        // 整体需要额外容纳的盒子数量
        n -= s;
        // 为了使整体能够额外容纳n个盒子，底部至少需要添加的数量x
        // 底部增加1个盒子，整体能够多容纳1个盒子=1
        // 底部增加2个盒子，整体能够多容纳3个盒子=1+2
        // 底部增加x个盒子，整体能够多容纳3个盒子=1+2+...+x
        // 也就是寻找最小的x，使得 1+2+3+...+x 大于等于n
        int x = 1;
        while ((n -= x) > 0) {
            x++;
        }
        // 最后答案为两部分之和
        ans += x;
        // 返回
        return ans;
    }

    public static void main(String[] args) {
        _1739_BuildingBoxes obj = new _1739_BuildingBoxes();
        System.out.println(obj.minimumBoxes(3));
    }
}
