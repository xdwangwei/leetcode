package com.daily;

/**
 * @author wangwei
 * @date 2023/6/8 14:19
 * @description: _1240_TilingARectangleWithFewestSquares
 *
 * 1240. 铺瓷砖
 * 你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。
 *
 * 房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。
 *
 * 假设正方形瓷砖的规格不限，边长都是整数。
 *
 * 请你帮设计师计算一下，最少需要用到多少块方形瓷砖？
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：n = 2, m = 3
 * 输出：3
 * 解释：3 块地砖就可以铺满卧室。
 *      2 块 1x1 地砖
 *      1 块 2x2 地砖
 * 示例 2：
 *
 *
 *
 * 输入：n = 5, m = 8
 * 输出：5
 * 示例 3：
 *
 *
 *
 * 输入：n = 11, m = 13
 * 输出：6
 *
 *
 * 提示：
 *
 * 1 <= n <= 13
 * 1 <= m <= 13
 * 通过次数13,734提交次数20,903
 */
public class _1240_TilingARectangleWithFewestSquares {


    /**
     * 方法：递归回溯 + 状态压缩
     *
     * 因为题目数据范围很小，因此可以回溯得到所有可行的方案，得到最小结果
     *
     * 我们可以按位置进行递归回溯，过程中我们用一个变量 t 记录当前使用的瓷砖数。
     *
     * 1.如果 j=m，即第 i 行已经被完全填充，则递归到下一行，即 (i+1,0)。
     * 2.如果 i=n，则表示所有位置都已经被填充，我们更新答案并返回。
     * 3.如果当前位置 (i,j) 已经被填充，则直接递归到下一个位置 (i,j+1)。
     * 4.如果 t+1 >= ans，提前回退到上一步，因为不论这个位置选多大的瓷砖，最后需要的瓷砖数并不会比已有方案更少，那没必要继续搜索
     * 5.否则，我们从大到小枚举当前位置 (i,j) 可以填充的正方形的边长 w，并将当前位置 (i,j) 到 (i+w−1,j+w−1) 的位置全部填充，然后递归到下一个位置 (i,j+w)。
     *
     *      这里下一个位置为什么不是 (i+w, j+w)
     *          首先，按照 1、2 逻辑，我们下一个位置选择 (i,j+w) 仍然能够走到 (i+w, j+w)
     *          其次，下一个位置选择(i+w, j+w)是错误的，会漏掉很多位置，
     *              比如 长为8，宽为5，从左上角开始，最大边长为5，
     *              下一个位置选择 (i+w, j+w) 直接就结束了，但是铺满 5x5 正方形后，右边 3X5 的窄条被扣掉了
     *      从大到小枚举当前位置 (i,j) 可以填充的正方形的边长 w 是为了提前剪枝，减少搜索次数
     *      理论上 (i,j) 位置为左上角能枚举的最大边长为 min(n-i, m-j)，
     *          但实际上，由于 回溯的存在，可能出现 这个区域内 已经有部分区域被别的正方形覆盖，那么 这个最大边长是无效的
     *          比如，
     *                 |*********|*********|   |
     *                 |    A    |    B    |   |
     *                 |*********|*********|   |
     *                 |         |         |   |
     *                 |         |         |   |
     *            当 B 部分回溯，枚举的边长变小时，下一个位置是D的左上角，选择了一个更大的矩形D
     *            这样，当遍历到 B 下面位置(x,y)时，以它为左上角，最大边长 min(n-x, m-y) 的一部分已经被 D 占据了，
     *                                          也就是以它为左上角的理论最大矩形中有一部分区域已经被别的正方形覆盖过了
     *                 |*********|*** |********|
     *                 |    A    |*B* |*  D   *|
     *                 |*********|    |********|
     *                 |         |    |        |
     *                 |         |    |        |
     *
     *
     *      所以，对于 (i,j) 为左上角，能得到的最大长度，需要遍历其 下边、右边 连续为0的位置的长度，得到二者的最小值
     *
     * 在回溯时，我们需要将当前位置 (i,j) 到 (i+w−1,j+w−1) 的位置全部清空。然后再枚举长度为 w-1 的正方形
     *
     * 实际上，这里可以简化
     *      我们枚举长度为w的矩形，dfs() 后续后，不全部回溯，只清空 (i,j) 到 (i+w−1,j+w−1) 的矩形的 最右列 和 最下行，
     *      这样，直接就得到了 边长为 w-1 时的矩形覆盖。
     *      重复这个过程，直到枚举边长为0，就完成了对所有可行边长的枚举
     *
     * 【空间优化】
     *
     * 由于每个位置只有两种状态：填充或者未填充，因此我们可以使用一个整数来表示当前位置的状态。
     *
     * 题目中n、m不超过13
     *
     * 我们使用一个长度为 n 的整数数组 filled，其中 filled[i] 表示第 i 行的状态。
     * 如果 filled[i] 的二进制的 第 j 位为 1，则表示第 i 行第 j 列已经被填充，否则表示未填充
     *
     * 作者：lcbin
     * 链接：https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/solution/python3javacgotypescript-yi-ti-yi-jie-di-tpge/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */
    private int n, m;
    private int[] filled;

    private int ans;

    public int tilingRectangle(int n, int m) {
        this.n = n;
        this.m = m;
        // filled 每一行都为0，代表所有位置都还未被覆盖
        this.filled = new int[n];
        // 将 ans 初始化为一个较大值
        ans = n * m;
        // 从左上角开始尝试，当前消耗的瓷砖数是0
        dfs(0, 0, 0);
        // 返回 所有方案 最少瓷砖数
        return ans;
    }

    /**
     * 回溯，
     * @param i
     * @param j 起始位置
     * @param t 已消耗的瓷砖数
     */
    private void dfs(int i, int j, int t) {
        // 当前行末，转下一行初始位置
        if (j == m) {
            i++;
            j = 0;
        }
        // 已经全部铺完，得到一种可行方案
        if (i == n) {
            // 更新 ans，这里不用 min(ans, t) 是因为 我们进一步dfs只在 t+1 < ans 时进行，所以这里不用比较，t 肯定是 <= ans 的
            ans = t;
            return;
        }
        // 这个位置已经铺上瓷砖了，遍历下一个位置
        if ((filled[i] >> j & 1) == 1) {
            dfs(i, j + 1, t);
            return;
        }
        // 当前无论尝试多大的瓷钻，所消耗的瓷砖数 都没有比 已有方案 更少
        // 当前方案并不能取得比已有方案更好的效果，结束
        if (t + 1 >= ans) {
            return;
        }
        // 得到 以 (i, j) 为左上角时，正方形可能的最大边长
        int mx = maxEdgeLen(i, j);
        // 先尝试最大边长，把这片区域全覆盖了
        for (int k = i; k < i + mx; ++k) {
            for (int l = j; l < j + mx; ++l) {
                filled[k] |= 1 << l;
            }
        }
        // 从大到小枚举所有可行的边长
        for(int w = mx; w > 0; --w) {
            // 下一个位置，注意下一个位置不是 (i+w,j+w)
            dfs(i, j + w, t + 1);
            // 回溯最后一列
            for (int k = i; k < i + w; ++k) {
                filled[k] ^= 1 << j + w - 1;
            }
            // 回溯最后一行（注意右下角位置已经回溯，需要排除）
            for (int k = j; k < j + w - 1; ++k) {
                filled[i + w - 1] ^= 1 << k;
            }
            // 回溯完后 ，filled 自然变成了 以 (i, j) 为左上角、边长为 w-1 时的情况，保证了正确性
        }
    }

    /**
     * 得到 以 (i, j) 为左上角时，正方形可能的最大边长
     * @param i
     * @param j
     * @return
     */
    private int maxEdgeLen(int i, int j) {
        int r = 0, c = 0;
        // 当前位置，向下，连续0（二进制）的最大长度
        for (int k = i; k < n; ++k) {
            if ((filled[k] >> j & 1) == 1) {
                break;
            }
            ++r;
        }
        // 当前位置，向右，连续0（二进制）的最大长度
        for (int k = j; k < m; ++k) {
            if ((filled[i] >> k & 1) == 1) {
                break;
            }
            ++c;
        }
        // 返回二者较小值
        return Math.min(r, c);
    }

    public static void main(String[] args) {
        _1240_TilingARectangleWithFewestSquares obj = new _1240_TilingARectangleWithFewestSquares();
        System.out.println(obj.tilingRectangle(5, 8));
    }
}
