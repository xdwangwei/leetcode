package com.daily;

/**
 * @author wangwei
 * @date 2023/2/10 19:22
 * @description: _1223_DiceRollSimulation
 *
 * 1223. 掷骰子模拟
 * 有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。
 *
 * 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。
 *
 * 现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。
 *
 * 假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 2, rollMax = [1,1,2,2,2,3]
 * 输出：34
 * 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
 * 示例 2：
 *
 * 输入：n = 2, rollMax = [1,1,1,1,1,1]
 * 输出：30
 * 示例 3：
 *
 * 输入：n = 3, rollMax = [1,1,1,2,2,3]
 * 输出：181
 *
 *
 * 提示：
 *
 * 1 <= n <= 5000
 * rollMax.length == 6
 * 1 <= rollMax[i] <= 15
 * 通过次数12,889提交次数21,422
 */
public class _1223_DiceRollSimulation {

    /**
     * 方法：动态规划
     *
     * 思路与算法
     *
     * 为了方便编写程序，我们重新定义骰子模拟器每次投掷生成的随机数为 0∼5，
     * 则连续掷出数字 i 的次数不能超过 rollMax[i]，其中 i∈[0,5]。
     *
     * 定义状态 d[i][j][k] 表示已经完成了 i 次掷骰子，第 i 次掷的是 j，并且已经连续掷了 k 次 j 的合法序列数。
     *
     * 初始状态从 i=1 开始，对于所有的 j∈[0,5]，令 d[1][j][1]=1。(只投一次，每个数字连续次数为1，方案数为1)
     *
     * 最终要返回的结果为：∑∑d[n][j][k]，其中 j∈[0,5],k∈[1,rollMax[j]]
     * 具体理解为：枚举最后一次投掷的结果（数字及连续次数），累加所有情况方案数
     *
     * 状态转移时，我们首先枚举表示上一次投掷的状态 d[i−1][j][k]，然后再枚举当前这一次投掷生成的随机数 p，
     * 根据 p 是否等于 j 来分情况转移：
     *
     * 若 p!=j，则令 d[i][p][1] 加上 d[i−1][j][k]。
     * 若 p=j，并且 k+1≤rollMax[j]，则令 d[i][p][k+1] 加上 d[i−1][j][k]。
     *
     *
     * 【进阶，未实现，可参考官方题解】
     * 空间优化
     *
     * 注意到状态转移过程中，d[i] 这一层状态仅依赖 d[i−1] 的状态，所以我们可以将 n 维状态表示压缩为 2 维，进一步优化空间。
     *
     * 具体的，我们令 t=i&1（其中 & 表示按位与运算），则 d[t][j][k] 表示原 d[i][j][k] 状态，
     * d[t⊕1][j][k] 表示原 d[i−1][j][k] 状态（其中 ⊕ 表示按位异或运算）。
     * 每次转移时，从 t⊕1 向 t 进行转移，注意转移之前需要将 d[t] 所有内容重置为 0。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/dice-roll-simulation/solution/zhi-tou-zi-mo-ni-by-leetcode-solution-yg0s/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @param rollMax
     * @return
     */
    private static final int MOD = (int) (1e9 + 7);
    public int dieSimulator(int n, int[] rollMax) {
        // rollMax.length = 6, max(rollMax[i]) = 15
        // d[i][j][k] 表示已经完成了 i 次掷骰子，第 i 次掷的是 j，且j连续次数为k 的合法序列数
        int[][][] dp = new int[n + 1][6][16];
        // 初始状态从 i=1 开始，对于所有的 j∈[0,5]，令 d[1][j][1]=1。(只投一次，每个数字连续次数为1，方案数为1)
        for (int j = 0; j < 6; ++j) {
            dp[1][j][1] = 1;
        }
        // 状态转移时，求 dp[i][j][k]
        for (int i = 2; i <= n; ++i) {
            for (int j = 0; j < 6; ++j) {
                for (int k = 1; k <= rollMax[j]; ++k) {
                    // 枚举表示上一次投掷的状态为 d[i−1][j][k]，
                    // 枚举当前这一次投掷生成的随机数 p，
                    for (int p = 0; p < 6; ++p) {
                        // 和上一次结果不一样，不再连续，第i次，p连续一次，
                        // 注意方案数是在原基础上累加，并且对 mod 取模
                        if (p != j) {
                            dp[i][p][1] = (dp[i][p][1] + dp[i - 1][j][k]) % MOD;
                        // 和上一次结果一样，重复次数+1，有效的前提是重复次数不能超过限制
                        } else if (k + 1 <= rollMax[j]) {
                            dp[i][p][k + 1] = (dp[i][p][k + 1] + dp[i - 1][j][k]) % MOD;
                        }
                    }
                }
            }
        }
        // 最终要返回的结果为：∑∑d[n][j][k]，其中 j∈[0,5],k∈[1,rollMax[j]]
        // 具体理解为：枚举最后一次投掷的结果（数字及连续次数），累加所有情况方案数
        int ans = 0;
        for (int j = 0; j < 6; ++j) {
            for (int k = 1; k <= rollMax[j]; ++k) {
                // 累加，并对 mod 取模
                ans = (ans + dp[n][j][k]) % MOD;

            }
        }
        // 返回
        return ans;
    }
}
