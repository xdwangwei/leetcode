package com.daily;

import java.util.Arrays;

/**
 * @author wangwei
 * @date 2023/2/11 14:51
 * @description: _2335_MinimumAccountOfTimeToFillCups
 * 2335. 装满杯子需要的最短总时长
 * 现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 2 杯 不同 类型的水或者 1 杯任意类型的水。
 *
 * 给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：amount = [1,4,2]
 * 输出：4
 * 解释：下面给出一种方案：
 * 第 1 秒：装满一杯冷水和一杯温水。
 * 第 2 秒：装满一杯温水和一杯热水。
 * 第 3 秒：装满一杯温水和一杯热水。
 * 第 4 秒：装满一杯温水。
 * 可以证明最少需要 4 秒才能装满所有杯子。
 * 示例 2：
 *
 * 输入：amount = [5,4,4]
 * 输出：7
 * 解释：下面给出一种方案：
 * 第 1 秒：装满一杯冷水和一杯热水。
 * 第 2 秒：装满一杯冷水和一杯温水。
 * 第 3 秒：装满一杯冷水和一杯温水。
 * 第 4 秒：装满一杯温水和一杯热水。
 * 第 5 秒：装满一杯冷水和一杯热水。
 * 第 6 秒：装满一杯冷水和一杯温水。
 * 第 7 秒：装满一杯热水。
 * 示例 3：
 *
 * 输入：amount = [5,0,0]
 * 输出：5
 * 解释：每秒装满一杯冷水。
 *
 *
 * 提示：
 *
 * amount.length == 3
 * 0 <= amount[i] <= 100
 * 通过次数17,160提交次数28,191
 *
 */
public class _2335_MinimumAccountOfTimeToFillCups {

    /**
     * 解法：贪心 & 分类讨论
     * 将饮料按数量从小到大排序，设数量为 x，y，z。我们的目标是匹配尽量多不同的饮料。
     *
     * 若 x + y ≤ z，显然每次用一个 z 和一个 x 或 y 匹配是最优的（每次生产2个不同，剩下的每次生产1个）。答案就是 z。
     * 若 x + y > z，考虑超出的部分 t=(x+y−z)。
     *      若 t 是偶数，那么我们可以先把 x 和 y 互相匹配 t/2 次进行“内部消化”。
     *              操作过后有 x+y=z，恢复到情况一，此时每次用一个 z 和一个 x 或 y 匹配即可。
     *              答案就是 t/2 + z。
     *      若 t 是奇数，仍然先将 x 和 y 互相匹配 (t-1)/2 次进行“内部消化”。
     *              操作过后有 x+y−1=z，即x+y<=z+1，恢复到情况一，
     *              此时每次用一个 z 和一个 x 或 y 匹配，剩下一杯无法匹配。
     *              答案就是 (t-1)/2 + z + 1 = (t + 1)/2 + z
     *
     *
     * 分类讨论第二条中的内部消化是一定可以进行那么多次的，如果无法进行那么多次 x 就耗尽了，说明原本 y>z，不符合假设。
     *
     * 总体复杂度 O(1)。
     *
     * 作者：tsreaper
     * 链接：https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/solution/by-tsreaper-158c/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param amount
     * @return
     */
    public int fillCups(int[] amount) {
        // 从小到大排序
        Arrays.sort(amount);
        int a = amount[0], b = amount[1], c = amount[2];
        // 每次用一个 c 和一个 a 或 b 匹配是最优的，剩下的 c 单独生产，答案为 c
        if (a + b <= c) {
            return c;
        }
        // 多出来部分
        int diff = a + b - c;
        // 先 a、b 消耗 (t+1)/2 次，转为 情况一，剩下需要 c+1
        return (diff + 1) / 2 + c;
    }
}
