package com.daily;

import java.util.Arrays;

/**
 * @author wangwei
 * @date 2022/12/5 12:26
 * @description: _1687_DeliveringBoxesFromStorageToPorts
 *
 * 1687. 从仓库到码头运输箱子
 * 你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。
 *
 * 给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [ports[i], weight[i]] 。
 *
 * ports[i] 表示第 i 个箱子需要送达的码头， weights[i] 是第 i 个箱子的重量。
 * portsCount 是码头的数目。
 * maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。
 * 箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：
 *
 * 卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。
 * 对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。
 * 卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。
 * 卡车在将所有箱子运输并卸货后，最后必须回到仓库。
 *
 * 请你返回将所有箱子送到相应码头的 最少行程 次数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
 * 输出：4
 * 解释：最优策略如下：
 * - 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。
 * 所以总行程数为 4 。
 * 注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。
 * 示例 2：
 *
 * 输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
 * 输出：6
 * 解释：最优策略如下：
 * - 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。
 * 总行程数为 2 + 2 + 2 = 6 。
 * 示例 3：
 *
 * 输入：boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
 * 输出：6
 * 解释：最优策略如下：
 * - 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
 * 总行程数为 2 + 2 + 2 = 6 。
 * 示例 4：
 *
 * 输入：boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
 * 输出：14
 * 解释：最优策略如下：
 * - 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
 * - 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。
 * - 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。
 * 总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。
 *
 *
 * 提示：
 *
 * 1 <= boxes.length <= 105
 * 1 <= portsCount, maxBoxes, maxWeight <= 105
 * 1 <= ports[i] <= portsCount
 * 1 <= weights[i] <= maxWeight
 */
public class _1687_DeliveringBoxesFromStorageToPorts {

    /**
     * 动态规划+贪心
     *
     * 三个前提：
     *      一、同一个码头的箱子不需要额外行程，所以把同一个码头的箱子装在一车上消耗的行程数 < 分开装在不同车上
     *          比如 [5,5,5] 装一起，共消耗 3 个 trip。[5]、[5]、[5] 消耗 6 个 trip
     *      二、不同码头的箱子尽可能装在一车上，比分开装不同车消耗的行程数少
     *          比如 [5,6,7] 装一起，共消耗 4 个 trip 。[5]、[6]、[7] 消耗 6 个 trip
     *
     *          综合：不要把同一码头的箱子拆开配送，也就是 对于 [1,2,3,4,4]，假如一次最多装4个箱子
     *                  如果按照每次全部装满的方案是 [1,2,3,4]、[4] 配送，
     *                  发现，所需行程数，比 按照 [1,2,3]、[4,4] 所需行程数更多
     *                  也就是说，【不能只贪心，必须特殊处理】
     *          总结：对于 贪心得到的一车配送区间[i...j]，如果存在 j 和 j + 1 的码头一致，应该把 j 留到下一车配送
     *                  准确的说，如果 [i...j] 中 [k...j] 码头一样，j 和 j + 1 码头一样，应该 把 [k...j] 留到下一车配送
     *                 如果 j 后面没有j+1了，拿就不用管了
     *      三、箱子需要按顺序配送
     *
     * 定义：dp[x] 代表 配送完 box[0...i] 所需的 最少 trip， 最后返回 dp[n-1]
     *
     * 按照前面所说，对于一车箱子，首先要尽可能装满，让卡车一次配送，然后再特殊处理
     * 假如当前车应该配送[i...j]，存在[k...j]码头一致，那么下一车应该从k开始考虑，
     * 但是这样跳跃迭代，会导致每次贪心确定范围时都需要重新遍历得到右边界，会有很多重复过程，包括其中的重量累计等，
     *
     * 因为我们通过枚举每车的装箱起点i来完成对dp的更新，采用滑动窗口对相关变量进行迭代更新，并且只更新最优的dp[x]，
     *
     * 左端点 i 从 0 到 n-1：对于每个i
     *
     *    从i往后累加weightSum，直到超过承载容量，假如最多承载 box[i....j]
     *    那么 dp[j] = dp[i-1] + numTrips[i...j]，这里的 numTrips[i...j] 表示卡车一次性配送这些箱子所需要的 trip
     *    即：配送完前j个箱子所需的最少trip = 配送完前i-1个箱子所需的最少trip + 配送 [i...j]箱子所需的 trip
     *    （这里相当于贪心）
     *
     *    另外，我们说了，如果存在后续 j+1 和 j 同一码头，那么 应当把 [i...j] 中 [k...j]部分留到下一车处理，[k...j] 为同一码头
     *    那么，对于这一车来说。我们应该更新 dp[k-1]
     *    dp[k-1] = dp[i-1] + numTrips[i...k-1]
     *    如果没有后续的j+1，或者 j+1 和 j 不是同一个码头，那么这一步可以省略
     *    （这里相当于对贪心漏掉情况的特殊处理）
     *
     *    如何计算 numTrips[i...j]
     *    首先 从 仓库 到 i，和 从 j 回到 仓库 需要 2，中间部分，如果 i 和 i+1 码头不同，就需要1个trip，假设共 numTrips 处
     *    因此，numTrips[i...j] = 2 + numTrips
     *
     *    如果存在 k，如何计算 k 和 numTrips[i...k-1]
     *    关于 k ：因为 [k...j] 的码头一致，因此在我们从i累加，直到j的过程中，每次遇到一个新码头时，就更新 k，
     *    关于 numTrips[i...k-1]：因为 [k...j] 码头一致，因此如果 k-1 和 k 的码头不一致，那么 numTrips[i...k-1] = numTrips - 1
     *
     * 每次i++，相当于滑动左窗口，此时更新
     *      weightSum -= boxes[i][1]
     *      if boxes[i][0] == boxes[i+1][0]  numTrips--;
     *      具体参考代码
     *
     *
     * 上述dp出现了 dp[x-1]，对于 < 0 的索引，认为 dp 值为 0，或者 dp 空间设置为 n+1
     *
     * @param boxes
     * @param portsCount
     * @param maxBoxes
     * @param maxWeight
     * @return
     */
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        // dp[i] 代表配送 [0...i] 所需最少trip
        int[] dp = new int[n];
        // 初始化dp数组
        Arrays.fill(dp, 2 * n);
        // 一次卡车（窗口内）在不超过阈值的情况下，箱子总重量，跟随滑动窗口左端点更新
        long weightSum = 0;
        // 用于 记录 每次 贪心确定的窗口 [i...j] 中 最后 [k...j] 部分的码头，
        int lastPort = -1;
        // 用于 记录 每次 贪心确定的窗口 [i...j] 中 最后 [k...j] 部分 k 索引，
        int numTrips = 0;
        // 用于 记录 每次 贪心确定的窗口 [i...j] 中 i和i+1码头不一样的情况有几个
        int k = -1;
        // 对于每个左端点，通过贪心所能达到的右端点
        int j = 0;
        // 枚举左端点，滑动窗口左端点，每次自增1
        // 不要把这个for循环理解为dp的迭代
        // dp[i] 代表配送[0...i]所需的最少trip，那么你应该考虑枚举最后一卡车配送了哪些，也就是从后往前考虑 dp[i-?]
        // 所以这里更偏向于从贪心和滑动窗口方向去考虑。从前往后，考虑每次贪心及贪心弥补，避免了大量重复过程
        for (int i = 0; i < n; ++i) {
            // 贪心，确定右边界
            while (j < n && j - i + 1 <= maxBoxes && weightSum + boxes[j][1] <= maxWeight) {
                // 窗口内总重量
                weightSum += boxes[j][1];
                // 更新 numTrips，这些箱子需要消耗1次trip
                if (j > 0 && boxes[j][0] != boxes[j - 1][0]) {
                    numTrips++;
                }
                // 找到 [i...j] 中 [k...j] 部分，这部分箱子码头一样
                if (boxes[j][0] != lastPort) {
                    lastPort = boxes[j][0];
                    k = j;
                }
                // 扩大右边界
                j++;
            }
            // 上面贪心确定的这一次卡车装 [i...j-1] 范围箱子
            // 那么 [0...j-1] 箱子就可以分为 配送 [0...i-1]所需最少trip + [i...j] 所需的trip
            // 配送 [0...i-1]所需最少trip 为 dp[i-1]，如果越界认为值为0
            // [i...j] 所需的trip = i到j之间所需numTrips 加上 从仓库去i 和 从j回仓库
            // 因为可能多次更新这个值，因此还是要取min
            dp[j - 1] = Math.min(dp[j - 1], (i > 0 ? dp[i - 1] : 0) + numTrips + 2);

            // 对于贪心确定的范围 [i...j]，如果存在后续箱子j+1和j为同一码头，那么 [k...j]应该留到下一次
            // 本次卡车应负责 [0...k-1]，注意不要越界
            // [0...k-1] 箱子可以分为 配送 [0...i-1]所需最少trip + [i...k-1] 所需的trip
            // 配送 [0...i-1]所需最少trip 为 dp[i-1]，如果越界认为值为0
            // [i...k-1] 所需的trip = i到j之间所需numTrips - 1  加上 从仓库去i 和 从k-1回仓库
            if (k > 0 && j < n && boxes[j - 1][0] == boxes[j][0]) {
                dp[k - 1] = Math.min(dp[k - 1], (i > 0 ? dp[i - 1] : 0) + numTrips - 1 + 2);
            }

            // 循环体结束i++，代表窗口左边界右移，此时更新窗口内 weightSum 和 numTrips
            weightSum -= boxes[i][1];
            if (i + 1 < n && boxes[i][0] != boxes[i + 1][0]) {
                numTrips--;
            }
        }
        // 返回
        return dp[n - 1];
    }

    public static void main(String[] args) {
        _1687_DeliveringBoxesFromStorageToPorts obj = new _1687_DeliveringBoxesFromStorageToPorts();
        System.out.println(obj.boxDelivering(new int[][]{{1, 2}, {3, 3}, {3, 1}, {3, 1}, {2, 4}}, 3, 3, 6));
    }
}
