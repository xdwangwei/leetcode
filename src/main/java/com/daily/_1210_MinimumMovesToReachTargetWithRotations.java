package com.daily;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Queue;

/**
 * @author wangwei
 * @date 2023/2/7 14:14
 * @description: _1210_MinimumMovesToReachTargetWithRotations
 *
 * 1210. 穿过迷宫的最少移动次数
 * 你还记得那条风靡全球的贪吃蛇吗？
 *
 * 我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。
 *
 * 每次移动，蛇可以这样走：
 *
 * 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
 * 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
 * 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。
 *
 * 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。
 *
 * 返回蛇抵达目的地所需的最少移动次数。
 *
 * 如果无法到达目的地，请返回 -1。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：grid = [[0,0,0,0,0,1],
 *                [1,1,0,0,1,0],
 *                [0,0,0,0,1,1],
 *                [0,0,1,0,1,0],
 *                [0,1,1,0,0,0],
 *                [0,1,1,0,0,0]]
 * 输出：11
 * 解释：
 * 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
 * 示例 2：
 *
 * 输入：grid = [[0,0,1,1,1,1],
 *                [0,0,0,0,1,1],
 *                [1,1,0,0,0,1],
 *                [1,1,1,0,0,1],
 *                [1,1,1,0,0,1],
 *                [1,1,1,0,0,0]]
 * 输出：9
 *
 *
 * 提示：
 *
 * 2 <= n <= 100
 * 0 <= grid[i][j] <= 1
 * 蛇保证从空单元格开始出发。
 * 通过次数14,246提交次数22,108
 */
public class _1210_MinimumMovesToReachTargetWithRotations {

    /**
     * 方法：广度优先搜索
     *
     * 思路与算法
     *
     * 【提示】
     * 由于蛇身占据两个两个单元格，我们只需要记录蛇尾位置，结合蛇身状态（水平或竖直）就能直到蛇头坐标，
     * 反之，记录蛇头坐标也可以得到蛇尾坐标。
     * 但是如果选择 (x,y) 表示蛇尾坐标，对于旋转操作（蛇尾不变，蛇头改变），无需进行坐标的转换。
     * 因此，选择记录【蛇尾】位置坐标
     *
     * 初始时，蛇身水平，蛇尾坐标为 (0,0)，蛇头坐标为 (0,1)；结束时，蛇身水平，蛇尾坐标为 (n-1,n-2)，蛇头坐标为 (n-1,n-1)
     *
     * 【思路与算法】
     * 求初始点到末尾点的最少移动次数，我们可以使用广度优先搜索的方法：
     * 广度优先搜索方法的正确性在于：我们一定不会到达同一个位置两次及以上，因为这样必定不是最少的移动次数。
     *
     * 如果不考虑蛇的旋转，队列中存放【蛇尾】的坐标 (x,y)，
     * 每次从队列中取出一个坐标时，尝试向右移动一个单元格到 (x,y+1)，或向下移动一个单元格到 (x+1,y)。
     * 最后返回到 (n−1,n−2) 最少需要的步数即可。
     *
     * 当考虑蛇的旋转时，我们可以有类似的结论。我们可以将蛇的状态本身与 (x,y) 一起形成一个三元组 (x,y,s)。
     * 这样一来，我们一定不会到达同一个三元组两次及以上。其中 s=0 表示水平状态，s=1 表示竖直状态。
     *
     * 因此，我们仍然可以使用广度优先搜索的方法解决本题。
     * 队列中元素为(x,y,s)这样的三元素，我们使用int[][][]记录初始点到每个点的最短路径，初始化为-1，
     * 按照bfs的特点，对于某个新的可达状态点，只在其对应dist[][][]值为-1时进行考虑，避免重复
     * 当然，本题只需返回到末尾位置的最少次数，因此也可以使用boolean[][][]记录某个点是否已经访问，不必记录到所有点的最少次数
     *
     * 【算法过程】
     * 初始化 dist[][][] 为 -1
     * 标记  dist[0][0][0] = 0，初始点，将 (0,0,0) 加入队列
     * （注意队列和dist记录的都是【蛇尾】位置坐标和蛇身方向）
     * 在队列非空情况下循环进行以下操作：
     *      弹出当前队首元素 (x,y,s)
     *
     *      当 s=0 时，需要考虑「向右移动」「向下移动」「顺时针旋转」三种情况；
     *
     *      「向右移动」：需要保证 (x,y+2) 是空的单元格（蛇本身占据了y和y+1，肯定是合理的，向右需要考虑y+2）；
     *                  新的蛇尾位置及方向为 (x,y+1,0)，需要保证 dist[x][y+1][0] == -1
     *                  此时更新 dist[x][y+1][0] = dist[x][y][0] + 1，将 (x,y+1,0)加入队列
     *      「向下移动」：需要保证 (x+1,y) 和 (x+1,y+1) 均是空的单元格；
     *                  新的蛇尾位置及方向为 (x+1,y,0)，需要保证 dist[x+1][y][0] == -1
     *                  此时更新 dist[x+1][y][0] = dist[x][y][0] + 1，将 (x+1,y,0)加入队列
     *      「顺时针旋转」：需要保证 (x+1,y) 和 (x+1,y+1) 均是空的单元格。
     *                  新的蛇尾位置及方向为 (x,y,1)，需要保证 dist[x][y][1] == -1
     *                  此时更新 dist[x][y][1] = dist[x][y][0] + 1，将 (x,y,1)加入队列
     *
     *      当 s=1 时，需要考虑「向右移动」「向下移动」「逆时针旋转」三种情况。
     *
     *      「向下移动」：需要保证 (x+2,y) 是空的单元格（蛇本身占据了x和x+1，肯定是合理的，向下需要考虑x+2）；
     *                  新的蛇尾位置及方向为 (x+1,y,1)，需要保证 dist[x+1][y][1] == -1
     *                  此时更新 dist[x+1][y][1] = dist[x][y][1] + 1，将 (x+1,y,1)加入队列
     *      「向右移动」：需要保证 (x,y+1) 和 (x+1,y+1) 均是空的单元格；
     *                  新的蛇尾位置及方向为 (x,y+1,1)，需要保证 dist[x][y+1][1] == -1
     *                  此时更新 dist[x][y+1][1] = dist[x][y][1] + 1，将 (x,y+1,1)加入队列
     *      「逆时针旋转」：需要保证 (x,y+1) 和 (x+1,y+1) 均是空的单元格。
     *                  新的蛇尾位置及方向为 (x,y,0)，需要保证 dist[x][y][0] == -1
     *                  此时更新 dist[x][y][0] = dist[x][y][1] + 1，将 (x,y,0)加入队列
     *
     *       注意下标不能越界！！！
     *
     * 【返回】
     * 结束时，蛇身水平，蛇尾坐标为 (n-1,n-2)，返回 dist[n-1][n-2][0]
     *
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solution/chuan-guo-mi-gong-de-zui-shao-yi-dong-ci-pmnh/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param grid
     * @return
     */
    public int minimumMoves(int[][] grid) {
        int n = grid.length;
        // 蛇尾位置(x,y)与蛇身方向形成一个三元组 (x,y,s)
        // 记录初始状态到每个状态点的最少移动次数
        int[][][] dist = new int[n][n][2];
        // 初始化，为-1代表bfs还未访问
        for (int[][] ints : dist) {
            for (int[] anInt : ints) {
                Arrays.fill(anInt, -1);
            }
        }
        // bfs
        Queue<int[]> q = new ArrayDeque<>();
        // 初始点入队列，蛇尾在(0,0),蛇身水平，s=0
        q.offer(new int[]{0, 0, 0});
        // 初始化初始点到初始点最少移动次数为0
        dist[0][0][0] = 0;
        // bfs
        while (!q.isEmpty()) {
            int sz = q.size();
            // 这里不用加这个for循环，只是写二叉树bfs习惯了。
            for (int i = 0; i < sz; ++i) {
                // 队首元素出队
                int[] cur = q.poll();
                // 得到坐标和方向
                int x = cur[0], y = cur[1], s = cur[2];
                // 水平方向
                if (s == 0) {
                    // 向右，需要保证 (x,y+2) 是空的单元格（蛇本身占据了y和y+1，肯定是合理的，向右需要考虑y+2）；
                    // 新的蛇尾位置及方向为 (x,y+1,0)，需要保证 dist[x][y+1][0] == -1
                    // 此时更新 dist[x][y+1][0] = dist[x][y][0] + 1，将 (x,y+1,0)加入队列
                    if (y + 2 < n && dist[x][y+1][0] == -1 && grid[x][y+2] == 0) {
                        dist[x][y+1][0] = dist[x][y][0] + 1;
                        q.offer(new int[]{x, y+1, 0});
                    }
                    // 向下，需要保证 (x+1,y) 和 (x+1,y+1) 均是空的单元格；
                    // 新的蛇尾位置及方向为 (x+1,y,0)，需要保证 dist[x+1][y][0] == -1
                    // 此时更新 dist[x+1][y][0] = dist[x][y][0] + 1，将 (x+1,y,0)加入队列
                    if (x + 1 < n && dist[x+1][y][0] == -1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {
                        dist[x+1][y][0] = dist[x][y][0] + 1;
                        q.offer(new int[]{x+1, y, 0});
                    }
                    // 顺时针旋转，需要保证 (x+1,y) 和 (x+1,y+1) 均是空的单元格。
                    // 新的蛇尾位置及方向为 (x,y,1)，需要保证 dist[x][y][1] == -1
                    // 此时更新 dist[x][y][1] = dist[x][y][0] + 1，将 (x,y,1)加入队列
                    if (x + 1 < n && dist[x][y][1] == -1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {
                        dist[x][y][1] = dist[x][y][0] + 1;
                        q.offer(new int[]{x, y, 1});
                    }
                } else {
                    // 向下，需要保证 (x+2,y) 是空的单元格（蛇本身占据了x和x+1，肯定是合理的，向下需要考虑x+2）；
                    // 新的蛇尾位置及方向为 (x+1,y,1)，需要保证 dist[x+1][y][1] == -1
                    // 此时更新 dist[x+1][y][1] = dist[x][y][1] + 1，将 (x+1,y,1)加入队列
                    if (x + 2 < n && dist[x+1][y][1] == -1 && grid[x+2][y] == 0) {
                        dist[x+1][y][1] = dist[x][y][1] + 1;
                        q.offer(new int[]{x+1, y, 1});
                    }
                    // 向右，需要保证 (x,y+1) 和 (x+1,y+1) 均是空的单元格；
                    // 新的蛇尾位置及方向为 (x,y+1,1)，需要保证 dist[x][y+1][1] == -1
                    // 此时更新 dist[x][y+1][1] = dist[x][y][1] + 1，将 (x,y+1,1)加入队列
                    if (y + 1 < n && dist[x][y+1][1] == -1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {
                        dist[x][y+1][1] = dist[x][y][1] + 1;
                        q.offer(new int[]{x, y+1, 1});
                    }
                    // 逆时针旋转，需要保证 (x,y+1) 和 (x+1,y+1) 均是空的单元格。
                    // 新的蛇尾位置及方向为 (x,y,0)，需要保证 dist[x][y][0] == -1
                    // 此时更新 dist[x][y][0] = dist[x][y][1] + 1，将 (x,y,0)加入队列
                    if (y + 1 < n && dist[x][y][0] == -1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {
                        dist[x][y][0] = dist[x][y][1] + 1;
                        q.offer(new int[]{x, y, 0});
                    }
                }
            }
        }
        // 结束时，蛇身水平，蛇尾坐标为 (n-1,n-2)，返回 dist[n-1][n-2][0]
        return dist[n-1][n-2][0];
    }
}
