package com.daily;

import java.util.Arrays;

/**
 * @author wangwei
 * @date 2022/11/18 14:48
 * @description: _891_SumOfSubsequenceWidths
 *
 * 891. 子序列宽度之和
 * 一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
 *
 * 给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
 *
 * 子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
 *
 *
 *
 * 示例 1：
 *
 * 输入：nums = [2,1,3]
 * 输出：6
 * 解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
 * 相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
 * 宽度之和是 6 。
 * 示例 2：
 *
 * 输入：nums = [2]
 * 输出：0
 *
 *
 * 提示：
 *
 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 105
 * 通过次数9,950提交次数22,840
 */
public class _891_SumOfSubsequenceWidths {

    /**
     * 计算每个元素对答案的贡献值
     *
     * 首先：子序列要求不连续，也就是在原数组中随意取值
     * 其次：子序列只关注最大值和最小值，也就是在元素组中枚举所有可能的最大最小值组合
     * 结论：对原数组排序并不会影响上述操作，也就不会影响最终结果
     *
     * 接着，考虑每个元素对最终答案的宽度贡献度
     *
     * 假如 x 作为 最大值 有 m 次，对应的最小值分别为 a1，a2，a3，....，am-1，
     *      那么这些宽度和就是 (x-a1) + (x-a2) + (x-a3) + ... (x-am-1) = m * x - (a1 + a2 + a3 + ... am-1)；
     * 假如 x 作为 最小值 有 n次，对应的最大值分别为 b1，b2，b3，....，bm-1，
     *      那么这些宽度和就是 (b1-x) + (b2-x) + (b3-x) + ... (bn-1-x) = (b1 + b2 + b3 + ... bn-1) - n * x；
     * 所以，如果单考虑x的贡献度的话，会发现在所有可能子序列宽度的统计情况中，和 x 有关的项是 m * x , -n * x ,
     *      合起来就是 (m - n ) * x， 也就是 (x作为最大值的次数 - x作为最小值的次数)
     *
     * 那么对于排序后的数组i位置上的元素nums[i]，以它为最大值的子序列情况有哪些：
     *      i位置必选，i 后面位置元素均不能选，i 前面位置元素都有可选可不选两种状态
     *      共 2 ^ i 种可能性
     * 同理可得，以 i 作为 最大值的子序列个数为 2 ^ (n - 1 - i)
     *
     * 综上：i 位置 nums[i] 对总的窗口贡献度为 nums[i] * (2^i - 2^(n-1-i))
     *
     * 为提高计算速度，提前准备power数组计算 2 的 i 次数，并同时 对 mod 进行取模处理
     *
     * 【注意】
     * 由于存在减法操作，所以可能出现 ans 为 负值的情况；因此 最终对 ans 再次处理 ans = (ans + mod) % mod
     * 并且对于数据类型选择，需要保证不能溢出
     *
     * 【是否存在重复计算】
     * 我们考虑每个元素对答案贡献度取决于它所在nums的位置，对于两个连续的x，由于对应的i不同，计算出的它为最大最小子序列的个数不同
     * 也就是说，分别充当了不同子序列的最大最小值，因此不存在重复计算
     * @param nums
     * @return
     */
    public int sumSubseqWidths(int[] nums) {
        int n = nums.length;
        int mod = (int)(1e9 + 7);
        // 预处理pow数组，用 long 类型存储
        long[] power = new long[n];
        power[0] = 1;
        // 顺便对mod取模
        for (int i = 1; i < n; ++i) {
            power[i] = power[i - 1] * 2 % mod;
        }
        // 排序
        Arrays.sort(nums);
        // 最终结果
        long ans = 0;
        // 累加每个元素的贡献值
        for (int i = 0; i < n; ++i) {
            ans += (power[i] - power[n - 1 - i]) * nums[i];
        }
        // 对mod取模处理，避免负数，二次处理
        ans = (ans % mod + mod) % mod;
        return (int)ans;
    }
}
