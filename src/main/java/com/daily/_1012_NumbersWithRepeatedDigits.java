package com.daily;

import java.util.ArrayList;
import java.util.List;

/**
 * @author wangwei
 * @date 2023/3/20 12:16
 * @description: _1012_NumbersWithRepeatedDigits
 *
 * 1012. 至少有 1 位重复的数字
 * 给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 20
 * 输出：1
 * 解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。
 * 示例 2：
 *
 * 输入：n = 100
 * 输出：10
 * 解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
 * 示例 3：
 *
 * 输入：n = 1000
 * 输出：262
 *
 *
 * 提示：
 *
 * 1 <= n <= 10^9
 * 通过次数10,278提交次数20,958
 */
public class _1012_NumbersWithRepeatedDigits {

    /**
     * 数位 DP
     *
     * 首先 [1,n] 共有 n 个数，而求解 [1,n] 范围内有多少个「至少有 1 位重复数字」的数的个数，等价于「总数 n」减去「没有重复数的数的个数」。
     *
     * 于是问题转换为：如何求解「没有重复数」的数的个数，
     * 同时为了更具一般性，我们将求解 [1,n] 范围内「没有重复数」的数的个数，修改为求解 [0,n] 范围内「没有重复数」的数的个数。
     *
     * 即将问题转换为 357. 统计各位数字都不同的数字个数 中的进阶部分 。
     * https://leetcode-cn.com/problems/count-numbers-with-unique-digits/solution/by-ac_oier-6tfl/
     *
     * 假定我们存在函数 int dp(int x) 函数，能够返回区间 [0,x] 内合法数的个数，
     * 那么配合「容斥原理」我们便能够回答任意区间合法数的查询：
     *
     *      ans(l,r) = dp(r) − dp(l−1)
     *
     * 然后考虑如何实现 int dp(int x) 函数，我们将组成 [0,x] 的合法数分成三类：
     *
     *      位数和 x 相同，且最高位比 x 最高位要小的，这部分统计为 res1；
     *      位数和 x 相同，且最高位与 x 最高位相同的，这部分统计为 res2；
     *      位数比 x 少，这部分统计为 res3。
     *
     * 求解 res3：位数比 x 少 = 1位数可能性 + 2位数可能性 + 3位数可能性 + ... + n-1位数可能性
     *           其中 1位数可能性为0-9共10种，
     *           从2往后，k 位数可能性 = 第k位数字可选 * 前k-1位数可能性 = (10-k-1) * 前k-1位数可能性
     *          ans = 10; // 一位数
     *          for (int i = 2, last = 9; i < n; i++) {
     *             // i位数的可能情况 = i-1位数的可能情况 * 第i位的可能取值
     *             int cur = last * (10 - i + 1);
     *             // 累加i位数的个数，更新 i位数的个数 为 计算i+1位数个数时的前i位数个数，即 更新 last 为 cur，进行下一轮循环
     *             ans += cur; last = cur;
     *         }
     *
     * 求解 res1 和 res2 的计算过程可以进行合并如下：
     *
     * 对 x 进行「从高到低」的处理得到每一位的数字（假定 x 数位为 n），
     * 对于当前构造的数字第 k 位而言，假设在 x 中第 k 位为 cur，
     * 那么为了满足「大小限制」关系，我们只能在 [0,cur] 范围内取数，且要满足「相同数字只能使用一次」的限制，
     *
     * 考虑 res1：当前位置取值比cur小，统计 [0,cur-1] 范围内同时符合两个限制条件的数的个数，记为 cnt。
     *      当第 k 位有 cnt 种合法选择之后，后面的位数可以在满足「相同数字只能使用一次」的限制条件下任意选择（大小关系已经由第 k 位保证），
     *      后面共 n-k 个位置，前 k 个位置占据了k个数据，
     *      后面第一个位置可以使用[0-9]-k共10-k个选择，第二个位置有10-k-1个选择，...，最后一个位置有 10-k - (n-k) + 1 种选则
     *      那么 res1 的所有可能为 当前位置选项 * 后续数字可能性 = cnt * (10-k)*(10-k-1)*(10-k-2)*...*(10-k - (n-k) + 1)
     *      为了快速知道剩下的 n−k 位有多少种方案，我们可以预处理乘积数组，其中 f[l][r] 代表 l∗(l+1)∗...∗(r−1)∗r 的乘积之和。i,j < 10
     * 考虑 res2：当前位置选择取值和cur相同
     *      可以使用cur的前提是这个数字并未被使用过
     *      因此我们需要使用一个 int 变量 s 二进制的低十位来代指数字 [0,9] 是否被使用），
     *      此时，如果 s>>cur & 1 == 1，cur已经使用，这种情况不成立，结束
     *      否则，更新 s |= 1 << cur，求解剩余n-k位数字的 res1 和 res2，也就是继续上面的过程
     *      当然了，如果此时 k==1，也就是已经是最后一位数字了，此处就cur一种选项，ans + 1 并结束
     *
     *
     * 其他细节：乘积数组的预处理与样例无关，我们可以使用 static 进行打表优化，同时可以将 res1 和 res2 两种情况进行合并。
     *
     * 作者：AC_OIer
     * 链接：https://leetcode.cn/problems/numbers-with-repeated-digits/solution/by-ac_oier-2szj/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @return
     */
    static int[][] f = new int[10][10];
    // 预处理得到 10以内 i*(i+1)*(i+2)*...*(j-1)*j 的值
    static {
        for (int i = 1; i < 10; i++) {
            f[i][i] = i;
            for (int j = i + 1; j < 10; j++) {
                f[i][j] = f[i][j - 1] * j;
            }
        }
    }

    /**
     * 1-n 范围内至少有 1位重复数字的正整数的个数。
     *      = n -  1-n范围内没有重复数字的整数的个数。
     *      = n+1 - 0-n范围内没有重复数字的整数的个数。
     *      = n+1 - dp(n)
     * @param n
     * @return
     */

    public int numDupDigitsAtMostN(int n) {
        return (n + 1) - dp(n);
    }

    /**
     * dp(x)：0-x范围内没有重复数字的整数个数
     * @param x
     * @return
     */
    int dp(int x) {
        List<Integer> nums = new ArrayList<>();
        int t = x;
        // 得到x的每一位，
        while (t != 0) {
            nums.add(t % 10);
            t /= 10;
        }
        int n = nums.size();
        // x是一位数
        if (n <= 1) {
            // 0，1，...，x 共 x+1 个数字
            return x + 1;
        }
        // 情况一二：位数和 x 相同（res1 + res2）
        // 位数和 x 相同，且最高位比 x 最高位要小的，这部分统计为 res1；
        // 位数和 x 相同，且最高位与 x 最高位相同的，这部分统计为 res2；
        int ans = 0;
        // nums需要倒序遍历，p指代将要构造的数字的从高到底的位数，取值为1到n，s的二进制代表已经选择过的数字的情况
        for (int p = 1, s = 0; p <= n; p++) {
            // 构造第p位，原数字x的对应位置的取值为 cur = nums.get(n - p)
            // res1：位数和 x 相同，且最高位比 x 最高位要小
            // cnt，构造数字第p位 小于 cur，且不重复情况下，第p位的取值情况
            int cur = nums.get(n - p), cnt = 0;
            // 第p位可以取 0 到 cur-1，如果是最高位，那么不能取0
            int low = p > 1 ? 0 : 1;
            for (int j = cur - 1; j >= low; j--) {
                // 枚举这些数字，如果没有被使用过，那么当前位置就可以选
                if (((s >> j) & 1) == 0) {
                    cnt++;
                }
            }
            // res1：当前位置选择小于cur的cnt种取值，第p+1个位置可选数值有10-p（前p位用过的数字）
            // 后续共有 n-p个位置，第1个位置可选10-p，那么最后一个位置可选数字为 ?，那么  10-p - ? + 1 = n-p，则 ? = 10-p -(n-p) + 1
            // 这低的n-p位数的数字组成共 first * (first-1) * ... * (last-1) * last = f[last][first]
            int first = 10 - p, last = first - (n - p) + 1;
            // 当前位置可选cnt种，后续数字 f[last][first] 种，合起来就是 cnt * f[last][first]
            // 当然了，如果当前是最后一个位置，那么 可能数值为cnt种，注意 f[][] 默认值是0
            // 这里已经考虑完了当前位小于cur时剩余位置组成的所有数字的情况，没有后续，所以不用考虑s的更新
            ans += p < n ? cnt * f[last][first] : cnt;

            // res2：位数和 x 相同，且最高位与 x 最高位相同的，这部分统计为 res2；
            // 也就是当前位置选择 cur，后续所有位置的可能取值就是 继续走外面的for循环
            // 如果 cur 这个数字已经被用过了，那么这种情况不存在，那么外围for循环不用继续了，直接结束这种情况
            if (((s >> cur) & 1) == 1) {
                break;
            }
            // 否则，res2：当前位置选择 cur，继续走外面的for循环 得到 后续所有位置的可能取值
            s |= (1 << cur);
            // res2：如果当前是最后一个位置，那 选择cur 就是一种选择，结束
            if (p == n) {
                ans++;
                // 这里是否break都行，因为p已经==n了，再进入for循环判断也会推出
                // break;
            }
        }
        // 情况三：位数比 x 少（res3），1位数，2位数，...，n-1位数
        // 一位数 0-9 共10个
        ans += 10;
        // i 表示 当前计算i位数的可能情况，i位数的个数为 前i-1位数的个数（last） * 第i位的可选个数
        // 从第2位往后，第二位可选数字9个，第三位可选8个，第四位可选7个，第i位可选10-i+1个
        // 1位数有10个，已统计过，不能有前导0，所以i从2开始，代表两位数，前2-1=1位数的取值有last=1-9共9个，当前位的可能取值有0-9减去前1位1种，共9个
        // 那么两位数的可能情况有cur= 9 * 9 = 81
        // ans += cur
        // 下一步计算i=3时，3位数的取值情况，前3-1=2位数的取值共last=上一个cur=81种，第3位的取值有 10-3+1=8种，
        // 那么三位数的情况有 cur = 81 * 8
        // ans += cur
        // 更新 last = cur，为计算四位数的可能情况做准备
        for (int i = 2, last = 9; i < n; i++) {
            // i位数的可能情况 = i-1位数的可能情况 * 第i位的可能取值
            int cur = last * (10 - i + 1);
            // 累加i位数的个数，更新 i位数的个数 为 计算i+1位数个数时的前i位数个数，即 更新 last 为 cur，进行下一轮循环
            ans += cur; last = cur;
        }
        return ans;
    }
}
