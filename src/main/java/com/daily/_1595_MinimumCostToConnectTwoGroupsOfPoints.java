package com.daily;

import java.util.Arrays;
import java.util.List;

/**
 * @author wangwei
 * @date 2023/6/20 13:04
 * @description: _1595_MinimumCostToConnectTwoGroupsOfPoints
 *
 * 1595. 连通两组点的最小成本
 * 给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 >= size2 。
 *
 * 任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。
 *
 * 返回连通两组点所需的最小成本。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 * 输入：cost = [[15, 96], [36, 2]]
 * 输出：17
 * 解释：连通两组点的最佳方法是：
 * 1--A
 * 2--B
 * 总成本为 17 。
 * 示例 2：
 *
 *
 *
 * 输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
 * 输出：4
 * 解释：连通两组点的最佳方法是：
 * 1--A
 * 2--B
 * 2--C
 * 3--A
 * 最小成本为 4 。
 * 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。
 * 示例 3：
 *
 * 输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
 * 输出：10
 *
 *
 * 提示：
 *
 * size1 == cost.length
 * size2 == cost[i].length
 * 1 <= size1, size2 <= 12
 * size1 >= size2
 * 0 <= cost[i][j] <= 100
 * 通过次数5,976提交次数9,965
 */
public class _1595_MinimumCostToConnectTwoGroupsOfPoints {

    /**
     * 方法：状态压缩 + 动态规划
     *
     * 我们记第一组的点数为 n，第二组的点数为 m。
     *
     * 假设 n=5,m=3。第一组的点编号为 0,1,2,3,4，第二组的点编号为 0,1,2。
     *
     * 用「枚举选哪个」来思考。
     *
     * 假设第一组前三个点都已经与第二组联通，此时考虑第一组的最后一个点（4），可以枚举它和第二组的 0,1,2 哪个点相连。
     * 假设和第二组的 1 相连，那么问题变成：「第一组的 0,1,2,3 和第二组相连，且第二组的1被连接， 0,2 未被连接时，最小成本是多少」。
     *
     * 由于 1 ≤ m ≤ n ≤ 12，因此，我们可以用一个整数来表示第二组中点的状态，即二进制表示的一个长度为 m 的整数，其中第 k 位为 1 表示第二组中的第 k 个点与第一组连通，为 0 表示不连通。
     *
     * 接下来，我们定义 f[i][j] 表示第一组中的前 i 个点已经全部与第二组连通，且第二组中的点的状态为 j 时的最小成本。
     *
     * 初始时 f[0][0]=0，其余值均为正无穷大。
     *
     * 答案即为 f[n][2^m−1]。（第一组前n个点都与第二组联通，且第二组m个点都已被第一组中的点连接），
     *
     * 从这里可以看出为什么要枚举第一组的点去选择第二组的点，而不是枚举第二组的点去与第一组相连，因此本题中 n >= m，所以 2^m < 2^n
     *
     * 对于 f[i][j]：第一组前i个数字与第二组联通，且第二组点的连接状态是j：
     *     其中 i 从 1 开始（f[i][?]代表集合1中【前i个】数字....，第i个数字是cost[i-1]）。 j 从 0 到 2^m-1
     *     考虑第一组前i个点的最后一个点（即第i个点），它到第二组每个点k的代价为 cost[i-1][k]
     *     考虑第一组第i个点是和第二组中哪个点进行连接
     *         枚举第二组j状态下被连接的点，即 j 二进制中为 1 的位置 k
     *         此时 第一组第i个点 连接了 第二组第k个点，考虑在此之前的状态（即 f[i][j] 的来源）
     *         情况一： 第一组前i-1个点 连接了 第二组 j⊕(1<<k)（除了k）的选中点，此时的代价为
     *             f[i-1][j⊕(1<<k)] + cost[i-1][k]
     *         情况二： 第一组前i-1个点 连接了 第二组 j（包括k）的选中点，此时的代价为
     *             f[i-1][j] + cost[i-1][k]
     *         情况三（不能漏掉）： 第一组前i-1个点 连接了 第二组 j⊕(1<<k)（除了k）的选中点，
     *                          且第一组 第 i 个点也已经选择了第二组中 k 之外的某个点，并且现在要继续 和 点k 建立连接
     *             即 第一组前i个点 连接了 第二组 j⊕(1<<k)（除了k）的选中点，此时的代价为
     *             f[i][j⊕(1<<k)] + cost[i-1][k]
     *
     *         三者取最小值 f[i][j] = min{f[i-1][j⊕(1<<k)], f[i-1][j], f[i][j⊕(1<<k)]} + cost[i-1][k]
     *
     * 最后，我们返回 f[n][2^m−1] 即可。
     * @param cost
     * @return
     */
    public int connectTwoGroups(List<List<Integer>> cost) {
        int n = cost.size(), m = cost.get(0).size();
        final int inf = 1 << 30;
        // f[i][j] 表示第一组中的前 i 个点已经全部与第二组连通，且第二组中的点的状态为 j 时的最小成本。
        int[][] f = new int[n + 1][1 << m];
        // f 求 最小值，初始化为 inf
        for (int[] g : f) {
            Arrays.fill(g, inf);
        }
        // base case
        f[0][0] = 0;
        // 递推，i 从 1 到 n
        for (int i = 1; i <= n; ++i) {
            // j 从 0 到 1 << n - 1
            for (int j = 0; j < 1 << m; ++j) {
                // 枚举此时，集合1的第i个元素连接的是 集合2 哪个元素
                for (int k = 0; k < m; ++k) {
                    // 即 此时 j 二进制为 1 的位置
                    if ((j >> k & 1) == 1) {
                        // 连接 i-k 的代价
                        int c = cost.get(i - 1).get(k);
                        // 情况一：集合1前i-1个元素连接了 j
                        f[i][j] = Math.min(f[i][j], f[i - 1][j] + c);
                        // 情况二：集合1前i-1个元素连接了 j除了k 之外的选中点
                        f[i][j] = Math.min(f[i][j], f[i - 1][j ^ (1 << k)] + c);
                        // 情况三：集合1前i个元素连接了 j除了k 之外的选中点，此时第i个元素继续连接k
                        f[i][j] = Math.min(f[i][j], f[i][j ^ (1 << k)]  + c);
                    }
                }
            }
        }
        // 返回 集合1前n个元素全部连接了集合2，且集合2中m个元素全都存在与集合1的连接
        return f[n][(1 << m) - 1];
    }
}
