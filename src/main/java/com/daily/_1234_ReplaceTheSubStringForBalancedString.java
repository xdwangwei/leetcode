package com.daily;

/**
 * @author wangwei
 * @date 2023/2/13 17:54
 * @description: _1234_ReplaceTheSubStringForBalancedString
 *
 * 1234. 替换子串得到平衡字符串
 * 有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。
 *
 * 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。
 *
 *
 *
 * 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。
 *
 * 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。
 *
 * 请返回待替换子串的最小可能长度。
 *
 * 如果原字符串自身就是一个平衡字符串，则返回 0。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "QWER"
 * 输出：0
 * 解释：s 已经是平衡的了。
 * 示例 2：
 *
 * 输入：s = "QQWE"
 * 输出：1
 * 解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 "RQWE" (或 "QRWE") 是平衡的。
 * 示例 3：
 *
 * 输入：s = "QQQW"
 * 输出：2
 * 解释：我们可以把前面的 "QQ" 替换成 "ER"。
 * 示例 4：
 *
 * 输入：s = "QQQQ"
 * 输出：3
 * 解释：我们可以替换后 3 个 'Q'，使 s = "QWER"。
 *
 *
 * 提示：
 *
 * 1 <= s.length <= 10^5
 * s.length 是 4 的倍数
 * s 中只含有 'Q', 'W', 'E', 'R' 四种字符
 * 通过次数20,207提交次数47,548
 */
public class _1234_ReplaceTheSubStringForBalancedString {

    /**
     * 滑动窗口
     *
     * 我们维护一个滑动窗口代表被选择的子串
     *
     * 然后使用计数的思想, 统计出不在子串内的每种字符的数量, 注意到无论如何更改被选择的子串的内容, 该数量只增不减,
     * 因此当前选择的子串是答案的必要条件是, 四种字符不在子串内的数量均 ≤n/4
     *
     * 容易证明该条件也是充分的:
     *
     * 设每种字符不在子串内有 a≤b≤c≤d≤n/4, 则滑动窗口内字符的大小为 n−a−b−c−d,
     * 将数量为 a 的字符补全到 n/4 个需要 n/4−a 个, 同理补全 b 需要 n/4−a 个, 补全 c 需要 n/4−c 个, 补全 d 需要 n/4−d 个,
     * 共需要 n/4−a+n/4−b+n/4−c+n/4−d=n−a−b−c−d, 恰消耗完滑动窗口长度个字符, 因此上述条件是充分的, 进而是充要的
     *
     * 因此我们的目标就是，找到最短的「待替换子串」，使得「不替换的内容」中四个字符的出现次数小于等于n/4。
     *
     * 那么我们如何去搜索最短的「待替换子串」，或者说我们对于当前得到的一个合法子串如何去进行进一步的搜索。
     * 我们记一个可以使得「不替换的内容」中四个字符的出现次数小于等于n/4的「待替换子串」为合法子串。
     *
     * 如果当前得到的子串是一个合法子串，那么我们考虑去缩短这个子串，看看有没有可能找到更短的合法子串；
     * 如果当前得到的子串不是合法子串，那么我们必须去延伸这个子串.
     * 【子串不合法，就说明「不替换的内容」中存在至少一个字符的出现次数大于n/4，
     * 我们就要通过加长子串缩短「不替换的内容」，让更多的字符被加入子串（窗口），使得「不替换的部分」字符数满足限制】
     *
     * 这样的搜索方式我们考虑使用一个滑动窗口[left, right]来维护搜索到的子串,
     * 我们从left=right=0即第一个字母构成的子串开始搜索。
     *
     * 如果当前子串不是一个合法子串，right右移延伸字符串；如果right已经到达字符串尾部，说明没有延伸的空间，那么就结束搜索。
     * 如果当前子串是一个合法子串，left右移缩短字符串；如果left已经到达字符串尾部，说明没有缩小的空间，那么就结束搜索。
     * 是否合法，只需要判断窗口外四个字符的数量是否都小于等于n/4即可，每次满足要求时，用当前窗口大小更新答案，选更小值
     * 因为我们在搜索过程中要时刻判断「不替换的内容」中四个字符的出现次数是否小于等于n/4，
     * 因此我们必须先遍历一遍整个字符串，得到字符的总共出现次数【初始化断「不替换的内容」中四个字符的出现次数，表示初始子串为空】，
     * 然后在滑动窗口的移动过程中，动态的增加或减少对应字符出现的次数，来维护「不替换的内容」中四个字符的出现次数。
     *
     * 作者：lxk1203
     * 链接：https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solution/javahua-dong-chuang-kou-de-fan-xiang-si-2dz8w/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     *
     * 作者：isuxiz
     * 链接：https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solution/1234-ti-huan-zi-chuan-de-dao-ping-heng-z-2ytv/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param s
     * @return
     */
    public int balancedString(String s) {
        int[] cnt = new int['X'];
        // 统计每个字符数量
        for (char c : s.toCharArray()) {
            cnt[c]++;
        }
        int n = s.length(), m = n / 4;
        // 已经平衡
        if (cnt['Q'] <= m && cnt['W'] <= m && cnt['E'] <= m && cnt['R'] <= m) {
            return 0;
        }
        // 滑动窗口，初始化 ans 为 n
        int right = 0, left = 0, ans = n;
        // 关注窗口外字符数量
        while (right < n) {
            // 当前字符加入窗口
            char c = s.charAt(right++);
            // 窗口外此字符的数量减少
            cnt[c]--;
            // 若当前窗口合理（合法子串，窗口外四个字符数量都满足限制）
            while (left < right && cnt['Q'] <= m && cnt['W'] <= m && cnt['E'] <= m && cnt['R'] <= m) {
                // 用当前窗口大小更新答案，选更小值
                ans = Math.min(ans, right - left);
                // 尝试缩小窗口，窗口左边界右移，窗口内左边界字符数量减少，对应窗口外此字符数量增加
                cnt[s.charAt(left++)]++;
            }
        }
        // 返回
        return ans;
    }
}
