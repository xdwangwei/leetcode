package com.order;

import java.util.ArrayList;
import java.util.List;

/**
 * @author wangwei
 * @date 2023/2/23 13:16
 * @description: _89_GrayCode
 *
 * 89. 格雷编码
 * n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
 * 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
 * 第一个整数是 0
 * 一个整数在序列中出现 不超过一次
 * 每对 相邻 整数的二进制表示 恰好一位不同 ，且
 * 第一个 和 最后一个 整数的二进制表示 恰好一位不同
 * 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 2
 * 输出：[0,1,3,2]
 * 解释：
 * [0,1,3,2] 的二进制表示是 [00,01,11,10] 。
 * - 00 和 01 有一位不同
 * - 01 和 11 有一位不同
 * - 11 和 10 有一位不同
 * - 10 和 00 有一位不同
 * [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
 * - 00 和 10 有一位不同
 * - 10 和 11 有一位不同
 * - 11 和 01 有一位不同
 * - 01 和 00 有一位不同
 * 示例 2：
 *
 * 输入：n = 1
 * 输出：[0,1]
 *
 *
 * 提示：
 *
 * 1 <= n <= 16
 * 通过次数111,667提交次数148,492
 */
public class _89_GrayCode {

    /**
     * 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），
     * 另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码[https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81]。
     * 格雷码的使用主要是为了减少相邻两个状态改变的位数，在实际电路中，就可以减少变化的电平数，从而降低因为电路错误带来无码的可能性。
     * 格雷码与二进制码的对应关系如下，以3位二进制码为例：
     *
     * 十进制          二进制         格雷码
     *   0             000           000
     *   1             001           001
     *   2             010           011
     *   3             011           010
     *   4             100           110
     *   5             101           111
     *   6             110           101
     *   7             111           100
     *
     * 格雷码生成方式：
     *
     * （一）递归：
     * 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造：
     *
     * 当n=0 时，格雷码序列为 [0]。
     * n 阶格雷码集合为 G(n)，则 G(n+1) 阶格雷码为：
     * G(n) 阶格雷码每个元素二进制形式前面添加 0，得到 G'(n) = G(n)；
     * 设 G(n) 集合倒序（镜像）为 R(n)，给 R(n) 每个元素二进制形式前面添加 1，得到 R'(n)；(最高位是n-1位)
     * G(n+1)=G'(n) ∪ R'(n) 拼接两个集合即可得到下一阶格雷码。
     * 根据以上规律，可从 0 阶格雷码推导致任何阶格雷码。
     *
     * （二）公式
     *
     * 自然二进制码与格雷码的转换
     * 将n位的自然二进制码转为对应的n位格雷码，从步骤如下：
     *
     * 对n位自然二进制的码字，从右到左，以0到n-1编号;
     * 如果自然二进制码字的第i位和i+1位相同，则对应的格雷码的第i位为0，否则为1（当i+1=n时，自然二进制码字的第n位被认为是0，即第n-1位不变）
     * 即G[i]=B[i]^B[i+1](B[n] = 0)
     *
     *
     * 可以看出，格雷码 = 自然二进制码 ^ 自然二进制码右移一位，即G = B ^ (B >> 1)
     *
     * 因此，对于一个整数 x，我们可以用函数 gray(x) 得到其格雷码：return x ^ (x >> 1)
     * 即 gray[0] = 0 ；；；gray[i] = gray[i] ^ (gray[i - 1])
     *
     *
     * 作者：lxk1203
     * 链接：https://leetcode.cn/problems/circular-permutation-in-binary-representation/solution/javage-lei-ma-zhuan-huan-zhi-xiang-lin-y-j5ox/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */


    /**
     * 递归（对称）法构造
     * @param n
     * @return
     */
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<>();
        ret.add(0);
        for (int i = 1; i <= n; ++i) {
            int sz = ret.size();
            // 倒序
            for(int k = sz - 1; k >= 0; --k) {
                // 每个数字最高位置1
                ret.add(ret.get(k) | (1 << (i - 1)));
            }
        }
        return ret;
    }

    /**
     * 公式法构造
     * @param n
     * @return
     */
    public List<Integer> grayCode2(int n) {
        List<Integer> ans = new ArrayList<>();
        // gray[0] = 0
        ans.add(0);
        for (int i = 1; i < 1 << n; ++i) {
            // gray[i] = gray[i] ^ (gray[i - 1])
            ans.add(i ^ (i >> 1));
        }
        return ans;
    }
}
