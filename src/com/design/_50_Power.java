package com.design;

/**
 * @author wangwei
 * 2022/2/28 19:57
 *
 * 50. Pow(x, n)
 * 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn ）。
 *
 *
 *
 * 示例 1：
 *
 * 输入：x = 2.00000, n = 10
 * 输出：1024.00000
 * 示例 2：
 *
 * 输入：x = 2.10000, n = 3
 * 输出：9.26100
 * 示例 3：
 *
 * 输入：x = 2.00000, n = -2
 * 输出：0.25000
 * 解释：2-2 = 1/22 = 1/4 = 0.25
 *
 *
 * 提示：
 *
 * -100.0 < x < 100.0
 * -231 <= n <= 231-1
 * -104 <= xn <= 104
 */
public class _50_Power {

    /**
     * 方法一：递归 + 快速幂
     * 快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x^64，我们可以按照：
     *
     *      x -> x^2 -> x^4 -> x^8 -> x^16 -> x^32 -> x^64 的顺序，
     *      从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 x^64 的值，而不需要对 x 乘 63 次 x。
     *
     * 再举一个例子，如果我们要计算 x^77
     *  ，我们可以按照：
     *
     *      x -> x^2 ->x^4 -> x^9 -> x^19 -> x^38 -> x^77 的顺序，
     *      在 x -> x^2，x^2 -> x^4，x^19 -> x^38, 这些步骤中，我们直接把上一次的结果进行平方，
     *      而在 x^4 -> x^9，x^9 -> x^19，x^38 -> x^77 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。
     *
     * 直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。
     * 但如果我们从右往左看，分治的思想就十分明显了：
     *
     *      当我们要计算 x^n时，我们可以先递归地计算出 y = x^⌊n/2⌋，其中 ⌊a⌋ 表示对 a 进行下取整；
     *
     *      根据递归计算的结果，如果 n 为偶数，那么 x^n = y^2；如果 nn 为奇数，那么 x^n = y^2 * x
     *      递归的边界为 n = 0n=0，任意数的 00 次方均为 11。
     *
     * 由于每次递归都会使得指数减少一半，因此递归的层数为 O(\log n)，算法可以在很快的时间内得到结果。
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param x
     * @param n
     * @return
     */
    public double myPow(double x, int n) {
        // -2^31 <= n <= 2^31 - 1
        long N = n;
        // A ^ -B = 1.0 / A^B
        // 为避免 -n 数据溢出，将其转为 long
        return N >= 0 ? power(x, N) : 1.0 / power(x, -N);
    }

    /**
     * 递归，快速幂
     * @param x
     * @param n
     * @return
     */
    public double power(double x, long n) {
        // base
        if (n == 0) {
            return 1.0;
        }
        // 快速幂
        // 偶数次方
        if (n % 2 == 0) {
            return power(x * x, n / 2);
        } else {
            return power(x * x, n / 2) * x;
        }
    }


    /**
     * 快速幂解析（二进制角度）：
     * 利用十进制数字 x 的二进制表示，可对快速幂进行数学化解释。
     *
     * 对于任何十进制正整数 x ，设其二进制为 "b_m...b_3 b_2 b_1 （ b_i 为二进制某位值，i∈[1,m] ），则有：
     *
     * x二进制转十进制： x = 1 b_1 + 2 b_2 + 4 b_3 + ... + 2^{m-1}b_m （即二进制转十进制公式） ；
     * x的幂的二进制展开： x^n = x^{1b_1 + 2b_2 + 4b_3 + ... + 2^{m-1}b_m} = x^{1b_1}x^{2b_2}x^{4b_3}...x^{2^{m-1}b_m}
     * 根据以上推导，可把计算 x^n 转化为解决以下两个问题：
     *      计算 x^1, x^2, x^4, ..., x^{2^{m-1} 的值： 循环赋值操作 x = x^2
     *      获取二进制各位 b_1, b_2, b_3, ..., b_m 的值： 循环执行以下操作即可。
     *      n&1 （与操作）： 判断 n 二进制最右一位是否为 1 ；
     *      n>>1 （移位操作）： n 右移一位（可理解为删除最后一位）。
     *
     *      其中：x^{2^{i-1}b_i}  =   ( b_i == 0 ) ？ 1 ： x^{2^{i-1}}
     * 因此，应用以上操作，可在循环中依次计算 x^{2^0b_1}, x^{2^1b_2}, ..., x^{2^{m-1}b_m}的值，
     *  并将所有 x^{2^{i-1}b_i}x 累计相乘即可，
     *
     * 算法流程：
     *  当 x = 0.0 时：直接返回 0.0 ，以避免后续 1 除以 0 操作报错。
     *  分析： 数字 0 的正数次幂恒为 0 ； 0 的 0 次幂和负数次幂没有意义，因此直接返回 0.0 即可。
     * 初始化 res = 1。
     *  当 n < 0 时：把问题转化至 n≥0 的范围内，即执行 x = 1/x，n = - n 。
     * 循环计算：当 n = 0 时跳出。
     *  当 n & 1 = 1 时：将当前 x 乘入 res （即  res∗=x ）。
     *  执行 x = x^2 （即 x *= xx∗=x ）。
     *  执行 n 右移一位（即 n >>= 1）。
     *
     * 返回 res 。
     *
     * 复杂度分析：
     * 时间复杂度 O(logn) ： 二分的时间复杂度为对数级别。
     * 空间复杂度 O(1)： resres, bb 等变量占用常数大小额外空间。

     *
     * 作者：jyd
     * 链接：https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param x
     * @param n
     * @return
     */
    public double myPow2(double x, int n) {

        // -2^31 <= n <= 2^31 - 1
        long N = n;
        // A ^ -B = 1.0 / A^B
        // 为避免 -n 数据溢出，将其转为 long
        return N >= 0 ? power2(x, N) : 1.0 / power2(x, -N);

    }

    /**
     * 根据 十进制数的 二进制表示得到规律，以计算 十进制数的 幂
     * @param x
     * @param n
     * @return
     */
    private double power2(double x, long n) {
        double res = 1.0;
        while (n > 0) {
            // bi 若 为 1，则 取 x^{2^(i-1)}
            if ((n & 1) == 1) {
                res *= x;
            }
            // 一直迭代，求出了 每一个 x^{2^(i-1)}
            x *= x;
            // 判断完后移除这个位
            n >>= 1;
        }
        return res;
    }
}
