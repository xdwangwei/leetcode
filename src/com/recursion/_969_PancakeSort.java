package com.recursion;

import java.util.ArrayList;
import java.util.List;

/**
 * @author wangwei
 * 2020/8/3 21:43
 *
 * 给定数组A，我们可以对其进行煎饼翻转：我们选择一些正整数k<= A.length，然后反转 A 的前 k个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。
 *
 * 返回能使A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在10 * A.length 范围内的有效答案都将被判断为正确。
 *
 *
 *
 * 示例 1：
 *
 * 输入：[3,2,4,1]
 * 输出：[4,2,4,3]
 * 解释：
 * 我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
 * 初始状态 A = [3, 2, 4, 1]
 * 第一次翻转后 (k=4): A = [1, 4, 2, 3]
 * 第二次翻转后 (k=2): A = [4, 1, 2, 3]
 * 第三次翻转后 (k=4): A = [3, 2, 1, 4]
 * 第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。
 * 示例 2：
 *
 * 输入：[1,2,3]
 * 输出：[]
 * 解释：
 * 输入已经排序，因此不需要翻转任何内容。
 * 请注意，其他可能的答案，如[3，3]，也将被接受。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/pancake-sorting
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class _969_PancakeSort {

    /**
     * 递归解法，虽然能找到解，但找到的不是最优解
     *
     * // cakes 是一堆烧饼，函数会将前 n 个烧饼排序
     * void sort(int[] cakes, int n);
     *
     * 如果我们找到了前 n 个烧饼中最大的那个，然后设法将这个饼子翻转到最底下：
     * 那么，原问题的规模就可以减小，递归调用 pancakeSort(A, n-1) 即可：
     * 接下来，对于上面的这 n - 1 块饼，如何排序呢？
     *      还是先从中找到最大的一块饼，然后把这块饼放到底下，再递归调用 pancakeSort(A, n-1-1)……
     * 你看，这就是递归性质，总结一下思路就是：
     *      1、找到 n 个饼中最大的那个。
     *      2、把这个最大的饼移到最底下。
     *      3、递归调用 pancakeSort(A, n - 1)。
     *      base case：n == 1 时，排序 1 个饼时不需要翻转。
     *
     * 那么，最后剩下个问题，如何设法将某块烧饼翻到最后呢？
     * 其实很简单，比如第 3 块饼是最大的，我们想把它换到最后，也就是换到第 n 块。
     * 可以这样操作：
     * 1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。
     * 2、用锅铲将前 n 块饼全部翻转，这样最大的饼就翻到了第 n 块，也就是最后一块。
     *
     * 在每次翻转烧饼时记录下翻转的是第几个烧饼
     * 唯一需要注意的是，数组索引从 0 开始，而我们要返回的结果是从 1 开始算的。
     *
     * 递归调用的次数是 n，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，
     * 所以总的复杂度是 O(n^2)。
     *
     * 最后，我们可以思考一个问题：
     * 按照我们这个思路，得出的操作序列长度应该为 2(n - 1)
     *      因为每次递归都要进行 2 次翻转并记录操作，总共有 n 层递归，
     *      但由于 base case 直接返回结果，不进行翻转，所以最终的操作序列长度应该是固定的 2(n - 1)。
     * 显然，这个结果不是最优的（最短的），比如说一堆煎饼 [3,2,4,1]，
     *
     * 【我们的算法】得到的翻转序列是 [3,4,2,3,1,2]，但是最快捷的翻转方法应该是 [2,3,4]：
     *
     *
     * @param A
     * @return
     */

    // 记录反转操作序列
    List<Integer> res = new ArrayList<>();

    // 烧饼排序
    public List<Integer> pancakeSort(int[] A) {
        pancakeSort(A, A.length);
        return res;
    }

    /**
     * cakes 是一堆烧饼，函数会将前 n 个烧饼排序
     * @param A
     * @param n
     */
    public void pancakeSort(int[] A,  int n) {
        // 如果只有一个饼，则不用翻转
        if (n == 1) return;

        int max = 0, maxIndex = 0;
        // 找到前n个饼中最大的那个
        for (int i = 0; i < n; i++) {
            if (A[i] > max) {
                max = A[i];
                maxIndex = i;
            }
        }
        // 第一次翻转，从这个饼下面翻一次，就可以把最大的饼放到最上面
        reverse(A, 0, maxIndex);
        // 记录此次翻转的位置
        res.add(maxIndex + 1);
        // 第二次翻转，再从最底下翻转一次，就可以把最大的饼翻转到最下面
        reverse(A, 0, n - 1);
        // 记录此次翻转的位置
        res.add(n);

        // 然后只需要递归，对上面的n-1个饼进行排序
        pancakeSort(A, n - 1);
    }

    /**
     * 反转数组arr [i,j]之间的元素
     * @param arr
     * @param i
     * @param j
     */
    private void reverse(int[] arr, int i, int j) {
        while (i < j) {
            // 交换arr[i] 和 arr[j]
            arr[i] = arr[i] ^ arr[j];
            arr[j] = arr[i] ^ arr[j];
            arr[i] = arr[i] ^ arr[j];
            i++; j--;
        }
    }
}
