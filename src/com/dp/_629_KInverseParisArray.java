package com.dp;

/**
 * @author wangwei
 * @date 2022/4/28 17:01
 * @description: _629_KInverseParisArray
 *
 * 629. K个逆序对数组
 * 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
 *
 * 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。
 *
 * 由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。
 *
 * 示例 1:
 *
 * 输入: n = 3, k = 0
 * 输出: 1
 * 解释:
 * 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
 * 示例 2:
 *
 * 输入: n = 3, k = 1
 * 输出: 2
 * 解释:
 * 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
 * 说明:
 *
 *  n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
 */
public class _629_KInverseParisArray {

    /**
     * 我们的目标是要求得前 n 个数的数组中正好有 k 个逆序对的数量，那么，我们可以思考一下，这个结果能否从前 n-1 个数的数组中转移过来？
     * 我现在有4位数字了，再加上一位会是什么情况
     *
     * 注意这里加上的新数是n+1，比已有的几位更大，一方面是使逆序对变化更清晰，再一方面就是更符合动态规划的规律
     * 【！！！】
     * 需要明确的是，加入新数字后，并未改变原有数字的相对位置，也就没有破坏他们的大小关系，也就是没有改变n个数字时的逆序对个数
     * 并且，新插入的数字n+1 只会 和它插入位置后面的数字形成逆序关系，因为它比他们大，对于它前面的数字来说，在后面放一个更大的数字，没有影响
     * 【----】
     * 具体考虑这个新数字n+1可以放置在原数组的哪个位置，和他后面的数字形成逆序关系，也就是它后面几个数字，就会多出几个逆序对
     *
     * xxxx5 => 多出0个逆序对
     * xxx5x => 多出1个逆序对 即：(5,第四个x)
     * xx5xx => 多出2个逆序对 即：(5,第四个x)，(5,第三个x)
     * x5xxx => 多出3个逆序对 即：(5,第四个x)，(5,第三个x)，(5,第二个x)
     * 5xxxx => 多出4个逆序对 即：(5,第四个x)，(5,第三个x)，(5,第二个x)，(5,第一个x)
     *
     * 那么如果用 dp[i][j]表示前i个数字(也就是1-i)恰好拥有k个逆序对时，对应的不同数组(只是元素位置不同)的个数
     *
     * 那么 当有i个数字时，如果想知道它有j个逆序对时的数组个数，那么根据 第 i 个数字 对前i-1个数字的插入位置不同：
     *
     * 插在 倒数第 0 个位置，会多出 0 个逆序对，那么如果 前i-1个数字的数组逆序对为 j - 0，这种情况下正好就 凑出i个数字的逆序对个数为 j
     * 插在 倒数第 1 个位置，会多出 1 个逆序对，那么如果 前i-1个数字的数组逆序对为 j - 1，这种情况下正好就 凑出i个数字的逆序对个数为 j
     * 插在 倒数第 2 个位置，会多出 2 个逆序对，那么如果 前i-1个数字的数组逆序对为 j - 2，这种情况下正好就 凑出i个数字的逆序对个数为 j
     * 插在 倒数第 i-1 个位置，会多出 i-1 个逆序对，那么如果 前i-1个数字的数组逆序对为 j - (i-1)，这种情况下正好就 凑出i个数字的逆序对个数为 j
     *
     * 所以 满足i个数字具有j个逆序对，的全部组合数应该等于，上面这些结果加起来
     * dp[i][j] = dp[i-1][j- 0] + dp[i-1][j- 1] + dp[i-1][j- 2] + ... + dp[i-1][j- (i-1)]
     * 得到了 dp[i][j] 和 dp[i-1][j] 的关系，还要知道 dp[i][j]和dp[i][j-1]的关系，将 j=j-1 代入上式
     * dp[i][j-1] = dp[i-1][j-1- 0] + dp[i-1][j-1- 1] + dp[i-1][j-1- 2] + ... + dp[i-1][j-1- (i-1)]
     *
     * 用上面式子减去下面式子得到
     * dp[i][j] - dp[i][j-1] = dp[i-1][j] - dp[i-1][j-i]
     * 即 dp[i][j] = dp[i][j−1] + dp[i−1][j] − dp[i−1][j−i] ,
     *
     * 因为 从1到i，凑成的 逆序对个数 最多有 i*(i-1)/2, 比如 [4,3,2,1] (4,3),(4,2),(4,1),(3,2),(3,1),(2,1) = 4*3/2 = 6
     * 所以 j 的取值范围： 0 <= j <= min(k, i*(i-1)/2)
     *
     * base case: dp[0][0] = 1， dp[0][>1] = 0
     *
     * return: dp[n][k]
     *
     *
     *
     * 作者：livorth-u
     * 链接：https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/629-kge-ni-xu-dui-shu-zu-dong-tai-gui-hu-qxyt/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     * @param n
     * @param k
     * @return
     */
    final int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        // dp[i][j] 为考虑使用数值 [1,i]，凑成逆序对数量恰好为 j 的数组个数
        int[][] dp = new int[n + 1][k + 1];
        // base case,其余 dp[0][>1] = 0
        dp[0][0] = 1;
        // 递推关系看上面注释，i 从1开始
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= Math.min(k, i * (i - 1) / 2); ++j) {
                // dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - i];
                // 针对 j < 1 和 j  < i 无意义的情况取 0
                // 并且，由于每个结果都要对mod取余数，导致后面表达式可能是负数，因此注意取余时先加mod，再取余
                // 注意 MOD 非常大， 因此 加 MOD 可能 int 溢出，需要先用long存储，取模结束再 转为int
                long temp = (j >= 1 ? dp[i][j - 1] : 0) + dp[i - 1][j] - (j >= i ? dp[i - 1][j - i] : 0);
                dp[i][j] = (int)((temp + MOD) % MOD);
            }
        }
        // return
        return dp[n][k];
    }

    /**
     * 由于 f[i][j] 只会从第 f[i-1][..]和 f[i][..] 转移而来，因此我们可以对动态规划使用的空间进行优化，即使用两个一维数组交替地进行状态转移，空间复杂度从 O(nk) 降低为 O(k)。
     * dp[0][j]前一状态，dp[1][j]当前状态
     * 每次迭代i，都要 将其映射到 0 和 1 分别得到前一状态和当前状态的索引
     * 由于 base case 是 dp[0][0]，然后 迭代时 i 从 1 开始
     * 那么 用 i & 1 就能得到 当前索引=1，cur ^ 1（注意是cur^1） 就能得到前一状态=0
     * 比如 对于 i=1时，前一状态应该是 初始 dp[0][j], 也就是 dp[i^1][j]
     *
     * 作者：LeetCode-Solution
     * 链接：https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/kge-ni-xu-dui-shu-zu-by-leetcode-solutio-0hkr/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */
    public int kInversePairs2(int n, int k) {
        // dp[i][j] 为考虑使用数值 [1,i]，凑成逆序对数量恰好为 j 的数组个数
        int[][] dp = new int[2][k + 1];
        // base case,其余 dp[0][>1] = 0
        dp[0][0] = 1;
        // 递推关系看上面注释，i 从1开始
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= Math.min(k, i * (i - 1) / 2); ++j) {
                // 只和前一状态有关，二维数组迭代即可
                int cur = i & 1, prev = cur ^ 1;
                // long temp = (j >= 1 ? dp[i][j - 1] : 0) + dp[i - 1][j] - (j >= i ? dp[i - 1][j - i] : 0);
                // dp[i][j] = (int)((temp + MOD) % MOD);
                long temp = (j >= 1 ? dp[cur][j - 1] : 0) + dp[prev][j] - (j >= i ? dp[prev][j - i] : 0);
                dp[cur][j] = (int)((temp + MOD) % MOD);
            }
        }
        // return 最后返回的是当前状态，不是前一状态
        return dp[n & 1][k];
    }
}
