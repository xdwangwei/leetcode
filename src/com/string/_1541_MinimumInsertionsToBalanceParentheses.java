package com.string;

/**
 * @author wangwei
 * 2022/3/25 10:58
 *
 * 1541. 平衡括号字符串的最少插入次数
 * 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
 *
 * 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
 * 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
 * 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
 *
 * 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
 *
 * 请你返回让 s 平衡的最少插入次数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "(()))"
 * 输出：1
 * 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。
 * 示例 2：
 *
 * 输入：s = "())"
 * 输出：0
 * 解释：字符串已经平衡了。
 * 示例 3：
 *
 * 输入：s = "))())("
 * 输出：3
 * 解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
 * 示例 4：
 *
 * 输入：s = "(((((("
 * 输出：12
 * 解释：添加 12 个 ')' 得到平衡字符串。
 * 示例 5：
 *
 * 输入：s = ")))))))"
 * 输出：5
 * 解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
 */
public class _1541_MinimumInsertionsToBalanceParentheses {

    /**
     * 与 _921_ 的不同在于，此时 一个 ( 需要匹配 两个 连续的 )
     * 需要注意的是，题目要求 【左括号 '(' 必须在对应的连续两个右括号 '))' 之前。】
     * 所以应该保证每次遇到左括号的时候，它【前面部分】的右括号数目应该是 偶数
     * @param s
     * @return
     */
    public int minInsertions(String s) {
        int len = s.length();
        // left 表示需要添加的左括号数目，right 表示 需要添加的 右括号数目
        int left = 0, right = 0;
        for (int i = 0; i < len; ++i) {
            // 遇到左括号
            if (s.charAt(i) == '(') {
                // 如果它前面部分右括号数目 是奇数
                // 那么应该在此处插入一个 ), 并且 原本所需要的 ) 数目 - 1
                // （比如你本来需要r个右括号，那我在这里插入一个右括号，你是不是只需要4个右括号了，但是我添加进去的括号数是不是多了1）
                if (right % 2 == 1) {
                    // right 表示的是需要的右括号数目，所以 right -=1
                    right--;
                    // 【！！！！！重要】
                    // 我们在这里加入了一个 ），因为left也是返回结果的一部分，所以这里用 left++ 只表示总共添加的括号数目增1
                    // 不代表添加的左括号数目+1
                    left++;

                    // 千万不要写成这样 left--; right++;
                    // 这表示，我们需要的右括号数目更多了，我们需要的左括号数目减少了，

                    // 你可能会说 ，res = left + right 那这两种写法的结果不是一样的嘛？
                    // 你需要注意的是 我们所有的判断都是围绕 right 展开的，你必须保证它的数值和它所代表的意义一直一致，否则就会出现问题。
                    // 我们用left++表示需要的括号数+1,虽然与 left 的意义（需要的左括号数）不匹配，但是 我们 不需要用left去做判断，我们只会在某个right条件成立的情况下，去给left++。甚至连--的代码都没有，
                    // 所以这样写结果才能保证正确

                    // 或者你干脆就别叫left了，就叫 ans 或者 res， 就 表示 需要添加的 括号数目（无论左右括号）
                    // 我们只是借助 right 的数值来 判断当前部分括号的匹配情况，以决定需要添加几个新的括号来位置平衡
                    // 也就是说 最终的目标一直都是 更新 res，right 只是用来 分情况讨论 不同情况下 res 如何更新

                    // 那为什么最后结果还是要 res + right呢？？
                    // 很简单，因为你这个for循环结束后，right不一定为0啊，这个时候 right 代表还需要这么多右括号，那么你肯定要给res加上去啊
                    // 就是说，for循环内你要更新res，for循环结束后你也得根据right更新res，
                }
                // 从当前位置开始的部分，所需右括号数目+2
                right += 2;
            } else {
                // 遇到右括号 ，right--
                right--;
                // 这种情况 ()) )
                if (right == -1) {
                    // 添加一个 ( 来匹配多出的那个 )
                    left++;
                    // 因为 一个 ( 需要两个 ), 所以 还需要一个 )
                    right = 1;
                }
            }
        }
        return left + right;
    }

    public static void main(String[] args) {
        _1541_MinimumInsertionsToBalanceParentheses obj = new _1541_MinimumInsertionsToBalanceParentheses();
        System.out.println(obj.minInsertions("()()("));
        System.out.println(obj.minInsertions("(()))(()))()())))"));
        System.out.println(obj.minInsertions("()()()()"));
    }
}
